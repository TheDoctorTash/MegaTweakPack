diff -uNr hdparm-6.9.orig/hdparm.8 hdparm-6.9/hdparm.8
--- hdparm-6.9.orig/hdparm.8	2006-10-25 16:41:33.000000000 +0200
+++ hdparm-6.9/hdparm.8	2006-11-09 21:09:35.000000000 +0100
@@ -311,6 +311,7 @@
 Some SATA drives support the control of this feature by pin 11 of
 the SATA power connector. In these cases, this command may be
 unsupported or may have no effect.
+.TP
 .I -S
 Set the standby (spindown) timeout for the drive.  This value is used
 by the drive to determine how long to wait (with no disk activity)
@@ -336,13 +337,8 @@
 of reading directly from the Linux buffer cache without disk access.
 This measurement is essentially an indication of the throughput of the
 processor, cache, and memory of the system under test.
-If the
-.I -t
-flag is also specified, then a correction factor based on the outcome of
-.I -T
-will be incorporated into the result reported for the
-.I -t
-operation.
+The cache read testing time can be specified by an optional numeric
+parameter. The default is 2 seconds. 
 .TP
 .I -t
 Perform timings of device reads for benchmark and comparison purposes.
@@ -356,13 +352,8 @@
 processing of
 .I -t
 using the BLKFLSBUF ioctl.
-If the
-.I -T
-flag is also specified, then a correction factor based on the outcome of
-.I -T
-will be incorporated into the result reported for the
-.I -t
-operation.
+The maximum read testing time can be specified by an optional numeric
+parameter. The default is 3 seconds. 
 .TP
 .I -u
 Get/set interrupt-unmask flag for the drive.  A setting of
@@ -593,6 +584,8 @@
 PIO data out security commands by Leonard den Ottolander
 <leonard den ottolander nl>, 2005.
 Parts by Benjamin Benz <bbe@heise.de> and others.
+.PP
+Windows version by Christian Franke <chrfranke@users.sourceforge.net>, 2006.
 .SH SEE ALSO
 .B http://www.t13.org/
 Technical Committee T13 ATA Attachment.
diff -uNr hdparm-6.9.orig/hdparm.c hdparm-6.9/hdparm.c
--- hdparm-6.9.orig/hdparm.c	2006-10-25 16:41:33.000000000 +0200
+++ hdparm-6.9/hdparm.c	2007-02-28 22:00:59.000000000 +0100
@@ -1,32 +1,48 @@
 /* hdparm.c - Command line interface to get/set hard disk parameters */
 /*          - by Mark Lord (C) 1994-2005 -- freely distributable */
-#include <unistd.h>
 #include <string.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <fcntl.h>
 #include <errno.h>
 #include <ctype.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#ifndef _WIN32
+#include <unistd.h>
+#include <sys/time.h>
+#endif
+#if !defined(_WIN32) && !defined(__CYGWIN__)
 #include <endian.h>
 #include <sys/ioctl.h>
 #include <sys/shm.h>
-#include <sys/stat.h>
 #include <sys/sysmacros.h>
-#include <sys/time.h>
 #include <sys/times.h>
-#include <sys/types.h>
 #include <sys/mount.h>
 #include <linux/types.h>
 #include <linux/hdreg.h>
 #include <linux/major.h>
 #include <asm/byteorder.h>
 //#include <endian.h>
+#else
+#ifndef __CYGWIN__
+#include "win32/timer.h"
+#endif
+#include "win32/fs.h"
+#include "win32/hdreg.h"
+#include "win32/shm.h"
+#include "win32/rawio.h"
+#include "win32/version.h"
+#define __le16_to_cpus(x) ((void)(x))
+#endif
 
 #include "hdparm.h"
 
 extern const char *minor_str[];
 
+#ifndef VERSION
 #define VERSION "v6.9"
+#endif
 
 #undef DO_FLUSHCACHE		/* under construction: force cache flush on -W0 */
 
@@ -34,9 +50,11 @@
 #define O_DIRECT	040000	/* direct disk access, not easily obtained from headers */
 #endif
 
+#if !defined(_WIN32) && !defined(__CYGWIN__)
 #ifndef CDROM_SELECT_SPEED	/* already defined in 2.3.xx kernels and above */
 #define CDROM_SELECT_SPEED	0x5322
 #endif
+#endif
 
 #ifndef BLKGETSIZE64
 #define BLKGETSIZE64		_IOR(0x12,114,size_t)
@@ -46,14 +64,30 @@
 #define TIMING_BUF_BYTES	(TIMING_BUF_MB * 1024 * 1024)
 
 char *progname;
-static int verbose = 0, get_identity = 0, get_geom = 0, noisy = 1, quiet = 0;
+static int verbose = 0, noisy = 1, quiet = 0;
 static int flagcount = 0, do_flush = 0;
 static int do_ctimings, do_timings = 0;
+static double ctimings = 0.0, timings = 0.0;
+
+#ifdef HDIO_GET_IDENTITY
+static int get_identity = 0;
+#endif
+#ifdef HDIO_GETGEO
+static int get_geom = 0;
+#endif
 
+#ifdef BLKRASET
 static unsigned long set_fsreadahead= 0, get_fsreadahead= 0, fsreadahead= 0;
+#endif
+#ifdef BLKROSET
 static unsigned long set_readonly = 0, get_readonly = 0, readonly = 0;
+#endif
+#ifdef HDIO_SET_UNMASKINTR
 static unsigned long set_unmask   = 0, get_unmask   = 0, unmask   = 0;
+#endif
+#ifdef HDIO_SET_MULTCOUNT
 static unsigned long set_mult     = 0, get_mult     = 0, mult     = 0;
+#endif
 #ifdef HDIO_SET_DMA
 static unsigned long set_dma      = 0, get_dma      = 0, dma      = 0;
 #endif
@@ -66,7 +100,9 @@
 #ifdef HDIO_GET_KEEPSETTINGS
 static unsigned long set_keep     = 0, get_keep     = 0, keep     = 0;
 #endif
+#ifdef HDIO_SET_32BIT
 static unsigned long set_io32bit  = 0, get_io32bit  = 0, io32bit  = 0;
+#endif
 #ifdef HDIO_SET_PIO_MODE
 static unsigned long set_piomode  = 0, noisy_piomode= 0;
 int piomode = 0;
@@ -87,18 +123,21 @@
 static unsigned long set_powerup_in_standby = 0, get_powerup_in_standby = 0, powerup_in_standby = 0;
 static unsigned long get_hitachi_temp = 0;
 
-#ifdef IDE_DRIVE_TASK_NO_DATA
 static unsigned long set_freeze   = 0;
+#ifndef WIN_SECURITY_FREEZE_LOCK
+	#define WIN_SECURITY_FREEZE_LOCK	0xF5
+#endif
+
+#ifdef IDE_DRIVE_TASK_NO_DATA
 static unsigned long security_master = 1, security_mode = 0;
 static unsigned long enhanced_erase = 0;
 static unsigned long set_security   = 0;
 
-#ifndef WIN_SECURITY_FREEZE_LOCK
+#ifndef WIN_SECURITY_SET_PASS
 	#define WIN_SECURITY_SET_PASS		0xF1
 	#define WIN_SECURITY_UNLOCK		0xF2
 	#define WIN_SECURITY_ERASE_PREPARE	0xF3
 	#define WIN_SECURITY_ERASE_UNIT		0xF4
-	#define WIN_SECURITY_FREEZE_LOCK	0xF5
 	#define WIN_SECURITY_DISABLE		0xF6
 #endif
 static unsigned int security_command = WIN_SECURITY_UNLOCK;
@@ -112,7 +151,9 @@
 #ifdef CDROM_SELECT_SPEED
 static unsigned long set_cdromspeed = 0, cdromspeed = 0;
 #endif /* CDROM_SELECT_SPEED */
+#ifdef HDIO_DRIVE_CMD
 static int get_IDentity = 0;
+#endif
 #ifdef HDIO_UNREGISTER_HWIF
 static int	unregister_hwif = 0;
 static int	hwif = 0;
@@ -126,8 +167,10 @@
 #ifdef HDIO_GET_BUSSTATE
 static int	set_busstate = 0, get_busstate = 0, busstate = 0;
 #endif
+#ifdef BLKRRPART
 static int	reread_partn = 0;
-#ifdef HDIO_GET_ACOUSTIC
+#endif
+#if defined(HDIO_GET_ACOUSTIC) || defined(HDIO_DRIVE_CMD)
 static int	set_acoustic = 0, get_acoustic = 0, acoustic = 0;
 #endif
 
@@ -138,8 +181,13 @@
 static int	perform_tristate = 0,	tristate = 0;
 #endif /* HDIO_TRISTATE_HWIF */
 
+#ifdef O_NONBLOCK
 static int open_flags = O_RDONLY|O_NONBLOCK;
+#else
+static int open_flags = O_RDONLY;
+#endif
 
+#ifdef HDIO_GET_IDENTITY
 // Historically, if there was no HDIO_OBSOLETE_IDENTITY, then
 // then the HDIO_GET_IDENTITY only returned 142 bytes.
 // Otherwise, HDIO_OBSOLETE_IDENTITY returns 142 bytes,
@@ -259,22 +307,10 @@
 			if (id->dma_ultra & 0x010)	strcat(umodes,"udma4 ");
 			if (id->dma_ultra & 0x2000)	strcat(umodes,"*");
 			if (id->dma_ultra & 0x020)	strcat(umodes,"udma5 ");
-#ifdef __NEW_HD_DRIVE_ID
-			if (id->hw_config & 0x2000) {
-#else /* !__NEW_HD_DRIVE_ID */
-			if (id->word93 & 0x2000) {
-#endif /* __NEW_HD_DRIVE_ID */
-				if (id->dma_ultra & 0x0800)	strcat(umodes,"*");
-				if (id->dma_ultra & 0x0008)	strcat(umodes,"udma3 ");
-				if (id->dma_ultra & 0x1000)	strcat(umodes,"*");
-				if (id->dma_ultra & 0x0010)	strcat(umodes,"udma4 ");
-				if (id->dma_ultra & 0x2000)	strcat(umodes,"*");
-				if (id->dma_ultra & 0x0020)	strcat(umodes,"udma5 ");
-				if (id->dma_ultra & 0x4000)	strcat(umodes,"*");
-				if (id->dma_ultra & 0x0040)	strcat(umodes,"udma6 ");
-				if (id->dma_ultra & 0x8000)	strcat(umodes,"*");
-				if (id->dma_ultra & 0x0080)	strcat(umodes,"udma7 ");
-			}
+			if (id->dma_ultra & 0x4000)	strcat(umodes,"*");
+			if (id->dma_ultra & 0x0040)	strcat(umodes,"udma6 ");
+			if (id->dma_ultra & 0x8000)	strcat(umodes,"*");
+			if (id->dma_ultra & 0x0080)	strcat(umodes,"udma7 ");
 		}
 	}
 	if ((id->capability&1) && (id->field_valid&2))
@@ -321,11 +357,15 @@
 	printf("\n");
 }
 
+#endif /* HDIO_GET_IDENTITY */
+
 void flush_buffer_cache (int fd)
 {
 	fsync (fd);				/* flush buffers */
+#ifdef BLKFLSBUF
 	if (ioctl(fd, BLKFLSBUF, NULL))		/* do it again, big time */
 		perror("BLKFLSBUF failed");
+#endif
 #ifdef HDIO_DRIVE_CMD
 	if (ioctl(fd, HDIO_DRIVE_CMD, NULL) && errno != EINVAL)	/* await completion */
 		perror("HDIO_DRIVE_CMD(null) (wait for flush complete) failed");
@@ -394,7 +434,10 @@
 	 * getitimer() is used rather than gettimeofday() because
 	 * it is much more consistent (on my machine, at least).
 	 */
-	setitimer(ITIMER_REAL, &(struct itimerval){{1000,0},{1000,0}}, NULL);
+	{
+		const struct itimerval tv = {{1000,0},{1000,0}};
+		setitimer(ITIMER_REAL, &tv, NULL);
+	}
 	if (seek_to_zero (fd)) return;
 	if (read_big_block (fd, buf)) return;
 	printf(" Timing %scached reads:   ", (open_flags & O_DIRECT) ? "O_DIRECT " : "");
@@ -414,7 +457,7 @@
 		getitimer(ITIMER_REAL, &e2);
 		elapsed = (e1.it_value.tv_sec - e2.it_value.tv_sec)
 		 + ((e1.it_value.tv_usec - e2.it_value.tv_usec) / 1000000.0);
-	} while (elapsed < 2.0);
+	} while (elapsed < ctimings);
 	total_MB = iterations * TIMING_BUF_MB;
 
 	elapsed = (e1.it_value.tv_sec - e2.it_value.tv_sec)
@@ -448,7 +491,7 @@
 		perror ("could not detach sharedmem buf");
 }
 
-static int do_blkgetsize (int fd, unsigned long long *blksize64)
+static int do_blkgetsize (int fd, __ull *blksize64)
 {
 	int		rc;
 	unsigned int	blksize32 = 0;
@@ -476,9 +519,9 @@
 	// get device size
 	//
 	if (do_ctimings || do_timings) {
-		unsigned long long blksize;
+		__ull blksize;
 		if (0 == do_blkgetsize(fd, &blksize))
-			max_iterations = blksize / (2 * 1024) / TIMING_BUF_MB;
+			max_iterations = (unsigned)(blksize / (2 * 1024) / TIMING_BUF_MB);
 	}
 
 	if ((shmid = shmget(IPC_PRIVATE, TIMING_BUF_BYTES, 0600)) == -1) {
@@ -509,7 +552,10 @@
 	 * getitimer() is used rather than gettimeofday() because
 	 * it is much more consistent (on my machine, at least).
 	 */
-	setitimer(ITIMER_REAL, &(struct itimerval){{1000,0},{1000,0}}, NULL);
+	{
+		const struct itimerval tv = {{1000,0},{1000,0}};
+		setitimer(ITIMER_REAL, &tv, NULL);
+	}
 
 	/* Now do the timings for real */
 	iterations = 0;
@@ -521,7 +567,7 @@
 		getitimer(ITIMER_REAL, &e2);
 		elapsed = (e1.it_value.tv_sec - e2.it_value.tv_sec)
 		 + ((e1.it_value.tv_usec - e2.it_value.tv_usec) / 1000000.0);
-	} while (elapsed < 3.0 && iterations < max_iterations);
+	} while (elapsed < timings && iterations < max_iterations);
 
 	total_MB = iterations * TIMING_BUF_MB;
 	if ((total_MB / elapsed) > 1.0)  /* more than 1MB/s */
@@ -733,12 +779,14 @@
 	if (!quiet)
 		printf("\n%s:\n", devname);
 
+#ifdef BLKRASET
 	if (set_fsreadahead) {
 		if (get_fsreadahead)
 			printf(" setting fs readahead to %ld\n", fsreadahead);
 		if (ioctl(fd, BLKRASET, fsreadahead))
 			perror(" BLKRASET failed");
 	}
+#endif
 #ifdef HDIO_UNREGISTER_HWIF
 	if (unregister_hwif) {
 		printf(" attempting to unregister hwif#%u\n", hwif);
@@ -773,12 +821,15 @@
 			perror(" HDIO_SET_PIO_MODE failed");
 	}
 #endif
+#ifdef HDIO_SET_32BIT
 	if (set_io32bit) {
 		if (get_io32bit)
 			printf(" setting 32-bit IO_support flag to %ld\n", io32bit);
 		if (ioctl(fd, HDIO_SET_32BIT, io32bit))
 			perror(" HDIO_SET_32BIT failed");
 	}
+#endif
+#ifdef HDIO_SET_MULTCOUNT
 	if (set_mult) {
 		if (get_mult)
 			printf(" setting multcount to %ld\n", mult);
@@ -788,6 +839,8 @@
 		else force_operation = 1;
 #endif
 	}
+#endif
+#ifdef BLKROSET
 	if (set_readonly) {
 		if (get_readonly) {
 			printf(" setting readonly to %ld", readonly);
@@ -796,6 +849,8 @@
 		if (ioctl(fd, BLKROSET, &readonly))
 			perror(" BLKROSET failed");
 	}
+#endif
+#ifdef HDIO_SET_UNMASKINTR
 	if (set_unmask) {
 		if (get_unmask) {
 			printf(" setting unmaskirq to %ld", unmask);
@@ -804,6 +859,7 @@
 		if (ioctl(fd, HDIO_SET_UNMASKINTR, unmask))
 			perror(" HDIO_SET_UNMASKINTR failed");
 	}
+#endif
 #ifdef HDIO_SET_DMA
 	if (set_dma) {
 		if (get_dma) {
@@ -844,6 +900,7 @@
 			perror(" HDIO_SET_KEEPSETTINGS failed");
 	}
 #endif /* HDIO_GET_KEEPSETTINGS */
+#ifdef HDIO_DRIVE_CMD
 	if (set_doorlock) {
 		unsigned char args[4] = {0,0,0,0};
 		args[0] = doorlock ? WIN_DOORLOCK : WIN_DOORUNLOCK;
@@ -875,7 +932,7 @@
 	}
 	if (set_prefetch) {
 		unsigned char args[4] = {WIN_SETFEATURES,0,0xab,0};
-		args[1] = prefetch;
+		args[1] = (char)prefetch;
 		if (get_prefetch)
 			printf(" setting drive prefetch to %ld\n", prefetch);
 		if (ioctl(fd, HDIO_DRIVE_CMD, &args))
@@ -924,12 +981,13 @@
 		} else {
 			/* set Advanced Power Management mode */
 			args[2] = 0x05; /* feature register */
-			args[1] = apmmode; /* sector count register */
+			args[1] = (unsigned char)apmmode; /* sector count register */
 			if (get_apmmode) printf(" 0x%02lX (%ld)\n",apmmode,apmmode);
 		}
 		if (ioctl(fd, HDIO_DRIVE_CMD, &args))
 			perror(" HDIO_DRIVE_CMD failed");
 	}
+#endif
 #ifdef CDROM_SELECT_SPEED
 	if (set_cdromspeed) {
 		printf ("setting cdrom speed to %ld\n", cdromspeed);
@@ -937,6 +995,7 @@
 			perror(" CDROM_SELECT_SPEED failed");
 	}
 #endif
+#ifdef HDIO_DRIVE_CMD
 	if (set_wcache) {
 #ifdef DO_FLUSHCACHE
 #ifndef WIN_FLUSHCACHE
@@ -990,7 +1049,8 @@
 		 && ioctl(fd, HDIO_DRIVE_CMD, &args2))
 			perror(" HDIO_DRIVE_CMD(sleep) failed");
 	}
-#if defined(WIN_SECURITY_FREEZE_LOCK) && defined(IDE_DRIVE_TASK_NO_DATA)
+#endif
+#if defined(WIN_SECURITY_SET_PASS) && defined(IDE_DRIVE_TASK_NO_DATA)
 	if (set_security) {
 #ifndef TASKFILE_OUT
 #define TASKFILE_OUT 4
@@ -1104,13 +1164,16 @@
 				printf("You need to configure your kernel with CONFIG_IDE_TASK_IOCTL.\n");
 		}
 	}
+#endif // defined(WIN_SECURITY_SET_PASS) && defined(IDE_DRIVE_TASK_NO_DATA)
+#if defined(WIN_SECURITY_FREEZE_LOCK) && defined(HDIO_DRIVE_CMD)
 	if (set_freeze) {
 		unsigned char args[4] = {WIN_SECURITY_FREEZE_LOCK,0,0,0};
 		printf(" issuing Security Freeze command\n");
 		if (ioctl(fd, HDIO_DRIVE_CMD, &args))
 			perror(" HDIO_DRIVE_CMD(freeze) failed");
 	}
-#endif // defined(WIN_SECURITY_FREEZE_LOCK) && defined(IDE_DRIVE_TASK_NO_DATA)
+#endif // defined(WIN_SECURITY_FREEZE_LOCK) && defined(HDIO_DRIVE_CMD)
+#ifdef HDIO_DRIVE_CMD
 	if (set_seagate) {
 		unsigned char args[4] = {0xfb,0,0,0};
 		if (get_seagate)
@@ -1119,7 +1182,7 @@
 			perror(" HDIO_DRIVE_CMD(seagatepwrsave) failed");
 	}
 	if (set_standby) {
-		unsigned char args[4] = {WIN_SETIDLE1,standby_requested,0,0};
+		unsigned char args[4] = {WIN_SETIDLE1,(unsigned char)standby_requested,0,0};
 		if (get_standby) {
 			printf(" setting standby to %lu", standby_requested);
 			interpret_standby(standby_requested);
@@ -1142,10 +1205,11 @@
 			printf("\n drive temperature in range:  %s\n", YN(!(args[1]&0x10)) );
 		}
 	}
-
+#endif
 	if (!flagcount)
 		verbose = 1;
 
+#ifdef HDIO_GET_MULTCOUNT
 	if (verbose || get_mult || get_identity) {
 		multcount = -1;
 		if (ioctl(fd, HDIO_GET_MULTCOUNT, &multcount)) {
@@ -1156,6 +1220,8 @@
 			on_off(multcount);
 		}
 	}
+#endif
+#ifdef HDIO_GET_32BIT
 	if (verbose || get_io32bit) {
 		if (0 == ioctl(fd, HDIO_GET_32BIT, &parm)) {
 			printf(" IO_support   =%3ld (", parm);
@@ -1173,13 +1239,15 @@
 			}
 		}
 	}
+#endif
+#ifdef HDIO_GET_UNMASKINTR
 	if (verbose || get_unmask) {
 		if (0 == ioctl(fd, HDIO_GET_UNMASKINTR, &parm)) {
 			printf(" unmaskirq    = %2ld", parm);
 			on_off(parm);
 		}
 	}
-
+#endif
 #ifdef HDIO_GET_DMA
 	if (verbose || get_dma) {
 		if (0 == ioctl(fd, HDIO_GET_DMA, &parm)) {
@@ -1220,6 +1288,7 @@
 		}
 	}
 #endif
+#ifdef BLKROGET
 	if (verbose || get_readonly) {
 		if (ioctl(fd, BLKROGET, &parm))
 			perror(" BLKROGET failed");
@@ -1228,6 +1297,8 @@
 			on_off(parm);
 		}
 	}
+#endif
+#ifdef BLKRAGET
 	if (verbose || get_fsreadahead) {
 		if (ioctl(fd, BLKRAGET, &parm))
 			perror(" BLKRAGET failed");
@@ -1236,8 +1307,10 @@
 			on_off(parm);
 		}
 	}
+#endif
+#ifdef HDIO_GETGEO
 	if (verbose || get_geom) {
-		unsigned long long blksize;
+		__ull blksize;
 		static const char msg[] = " geometry     = %u/%u/%u, sectors = %lld, start = %ld\n";
 // Note to self:  when compiled 32-bit (AMD,Mips64), the userspace version of this struct
 // is going to be 32-bits smaller than the kernel representation.. random stack corruption!
@@ -1258,6 +1331,7 @@
 				printf(msg, g.cylinders, g.heads, g.sectors, blksize, g.start);
 		}
 	}
+#endif
 #ifdef HDIO_DRIVE_CMD
 	if (get_powermode) {
 #ifndef WIN_CHECKPOWERMODE1
@@ -1294,12 +1368,13 @@
 			perror(" HDIO_TRISTATE_HWIF failed");
 	}
 #endif /* HDIO_TRISTATE_HWIF */
+#ifdef HDIO_GET_IDENTITY
 	if (get_identity) {
 		static struct hd_driveid id;
 
 		if (!ioctl(fd, HDIO_GET_IDENTITY, &id)) {
 			if (multcount != -1) {
-				id.multsect = multcount;
+				id.multsect = (unsigned char)multcount;
 				id.multsect_valid |= 1;
 			} else
 				id.multsect_valid &= ~1;
@@ -1309,6 +1384,8 @@
 		else
 			perror(" HDIO_GET_IDENTITY failed");
 	}
+#endif
+#ifdef HDIO_DRIVE_CMD
 	if (get_IDentity) {
 		__u16 *id;
 		unsigned char args[4+512] = {WIN_IDENTIFY,0,0,1,}; // FIXME?
@@ -1334,6 +1411,7 @@
 		}
 identify_abort:	;
 	}
+#endif
 #ifdef HDIO_SET_BUSSTATE
 	if (set_busstate) {
 		if (get_busstate) {
@@ -1354,12 +1432,14 @@
 		}
 	}
 #endif
+#ifdef BLKRRPART
 	if (reread_partn) {
 		if (ioctl(fd, BLKRRPART, NULL)) {
 			perror(" BLKRRPART failed");
 		}
 	}
- #ifdef HDIO_SET_ACOUSTIC
+#endif
+#ifdef HDIO_DRIVE_CMD
 	if (set_acoustic) {
 		if (get_acoustic) {
 			printf(" setting acoustic management to %d\n", acoustic);
@@ -1413,37 +1493,62 @@
 
 	fprintf(desc,"\n%s - get/set hard disk parameters - version %s\n\n", progname, VERSION);
 	fprintf(desc,"Usage:  %s  [options] [device] ..\n\n", progname);
+#if defined(_WIN32) || defined(__CYGWIN__)
+	fprintf(desc,"Device:\n"
+	" /dev/hd[a-z]    harddisk 0,1,...\n"
+	" /dev/sd[a-z]    harddisk 0,1,...\n"
+	" /dev/scd[0-9]   cd-rom 0,1,...\n\n");
+#endif
 	fprintf(desc,"Options:\n"
+#ifdef BLKRASET
 	" -a   get/set fs readahead\n"
+#endif
 #ifdef HDIO_DRIVE_CMD
 	" -A   set drive read-lookahead flag (0/1)\n"
 #endif
 #ifdef HDIO_GET_BUSSTATE
 	" -b   get/set bus state (0 == off, 1 == on, 2 == tristate)\n"
 #endif
+#ifdef HDIO_DRIVE_CMD
 	" -B   set Advanced Power Management setting (1-255)\n"
+#endif
+#ifdef HDIO_SET_32BIT
 	" -c   get/set IDE 32-bit IO setting\n"
+#endif
 #ifdef HDIO_DRIVE_CMD
 	" -C   check IDE power mode status\n"
 #endif
 #ifdef HDIO_SET_DMA
 	" -d   get/set using_dma flag\n"
 #endif
+#if defined(_WIN32) || defined(__CYGWIN__)
+	" --debug   enable debugging output\n"
+#endif
 	" --direct  use O_DIRECT to bypass page cache for timings\n"
+#ifdef HDIO_DRIVE_CMD
 	" -D   enable/disable drive defect management\n"
+#endif
 #ifdef CDROM_SELECT_SPEED
 	" -E   set cd-rom drive speed\n"
 #endif
 	" -f   flush buffer cache for device on exit\n"
+#ifdef HDIO_GETGEO
 	" -g   display drive geometry\n"
+#endif
 	" -h   display terse usage information\n"
 #ifdef HDIO_DRIVE_CMD
 	" -H   read temperature from drive (Hitachi only)\n"
 #endif
+#ifdef HDIO_GET_IDENTITY
 	" -i   display drive identification\n"
+#endif
+#ifdef HDIO_DRIVE_CMD
 	" -I   detailed/current information directly from drive\n"
+#endif
 	" --Istdin  read identify data from stdin as ASCII hex\n"
+#ifdef HDIO_DRIVE_CMD
 	" --Istdout write identify data to stdout as ASCII hex\n"
+#endif
 #ifdef HDIO_GET_KEEPSETTINGS
 	" -k   get/set keep_settings_over_reset flag (0/1)\n"
 #endif
@@ -1454,7 +1559,9 @@
 #ifdef HDIO_GET_ACOUSTIC
 	" -M   get/set acoustic management (0-254, 128: quiet, 254: fast) (EXPERIMENTAL)\n"
 #endif /* HDIO_GET_ACOUSTIC */
+#ifdef HDIO_SET_MULTCOUNT
 	" -m   get/set multiple sector count\n"
+#endif
 #ifdef HDIO_SET_NOWERR
 	" -n   get/set ignore-write-errors flag (0/1)\n"
 #endif
@@ -1468,7 +1575,9 @@
 #ifdef HDIO_GET_QDMA
 	" -Q   get/set DMA tagged-queuing depth (if supported)\n"
 #endif
+#ifdef BLKROSET
 	" -r   get/set device  readonly flag (DANGEROUS to set)\n"
+#endif
 #ifdef HDIO_SCAN_HWIF
 	" -R   register an IDE interface (DANGEROUS)\n"
 #endif
@@ -1478,28 +1587,62 @@
 #endif
 	" -t   perform device read timings\n"
 	" -T   perform cache read timings\n"
+#ifdef HDIO_SET_UNMASKINTR
 	" -u   get/set unmaskirq flag (0/1)\n"
+#endif
 #ifdef HDIO_UNREGISTER_HWIF
 	" -U   un-register an IDE interface (DANGEROUS)\n"
 #endif
-	" -v   defaults; same as -mcudkrag for IDE drives\n"
+	" -v   defaults; same as -"
+#ifdef HDIO_SET_MULTCOUNT
+	                         "m"
+#endif
+#ifdef HDIO_SET_32BIT
+	                          "c"
+#endif
+#ifdef HDIO_SET_UNMASKINTR
+	                           "u"
+#endif
+#ifdef HDIO_SET_DMA
+	                            "d"
+#endif
+#ifdef HDIO_GET_KEEPSETTINGS
+	                             "k"
+#endif
+#ifdef BLKROSET
+	                              "r"
+#endif
+#ifdef BLKRASET
+	                               "a"
+#endif
+#ifdef HDIO_GETGEO
+	                                "g"
+#endif
+	                                  " for IDE drives\n"
 	" -V   display program version and exit immediately\n"
-#ifdef HDIO_DRIVE_CMD
 #ifdef HDIO_DRIVE_RESET
 	" -w   perform device reset (DANGEROUS)\n"
 #endif
+#ifdef HDIO_DRIVE_CMD
 	" -W   set drive write-caching flag (0/1) (DANGEROUS)\n"
+#endif
 #ifdef HDIO_TRISTATE_HWIF
 	" -x   tristate device for hotswap (0/1) (DANGEROUS)\n"
 #endif
+#ifdef HDIO_DRIVE_CMD
 	" -X   set IDE xfer mode (DANGEROUS)\n"
 	" -y   put IDE drive in standby mode\n"
 	" -Y   put IDE drive to sleep\n"
 	" -Z   disable Seagate auto-powersaving mode\n"
+#endif
+#ifdef BLKRRPART
 	" -z   re-read partition table\n"
 #endif
-#if defined(WIN_SECURITY_FREEZE_LOCK) && defined(IDE_DRIVE_TASK_NO_DATA)
+#if defined(WIN_SECURITY_SET_PASS) && defined(IDE_DRIVE_TASK_NO_DATA)
 	" --security-help  display help for ATA security commands\n"
+#elif defined(WIN_SECURITY_FREEZE_LOCK) && defined(HDIO_DRIVE_CMD)
+	" --security-freeze   Freeze security settings until reset\n"
+	" (remaining ATA security commands were unavailable at build time)\n"
 #else
 	" (ATA security commands were unavailable at build time)\n"
 #endif
@@ -1507,7 +1650,7 @@
 	exit(ret);
 }
 
-#if defined(WIN_SECURITY_FREEZE_LOCK) && defined(IDE_DRIVE_TASK_NO_DATA)
+#if defined(WIN_SECURITY_SET_PASS) && defined(IDE_DRIVE_TASK_NO_DATA)
 static void security_help (void)
 {
 	printf("\n"
@@ -1635,9 +1778,15 @@
 	char c, *p, *p1;
 	char *tmpstr;
 	char name[32];
+#ifdef HDIO_GET_QDMA
 	int neg;
+#endif
 
+#ifndef _WIN32
 	if  ((progname = (char *) strrchr(*argv, '/')) == NULL)
+#else
+	if  ((progname = (char *) strrchr(*argv, '\\')) == NULL)
+#endif
 		progname = *argv;
 	else
 		progname++;
@@ -1653,16 +1802,25 @@
 				++flagcount;
 				continue;
 			}
+#if defined(_WIN32) || defined(__CYGWIN__)
+			if (0 == strcmp(p, "--debug")) {
+				win32_debug++;
+				++flagcount;
+				continue;
+			}
+#endif
 			if (0 == strcmp(p, "--Istdin")) {
 				identify_from_stdin();
 				++flagcount;
 				continue;
 			}
+#ifdef HDIO_DRIVE_CMD
 			if (0 == strcmp(p, "--Istdout")) {
 				get_IDentity = 2;
 				++flagcount;
 				continue;
 			}
+#endif
 			if (!*++p)
 				usage_error(1);
 			while ((c = *p++)) {
@@ -1675,15 +1833,21 @@
 					case 'v':
 						verbose = 1;
 						break;
+#ifdef HDIO_DRIVE_CMD
 					case 'I':
 						get_IDentity = 1;
 						break;
+#endif
+#ifdef HDIO_GET_IDENTITY
 					case 'i':
 						get_identity = 1;
 						break;
+#endif
+#ifdef HDIO_GETGEO
 					case 'g':
 						get_geom = 1;
 						break;
+#endif
 					case 'f':
 						do_flush = 1;
 						break;
@@ -1691,6 +1855,7 @@
 						quiet = 1;
 						noisy = 0;
 						break;
+#ifdef HDIO_SET_UNMASKINTR
 					case 'u':
 						get_unmask = noisy;
 						noisy = 1;
@@ -1701,6 +1866,7 @@
 							unmask = *p++ - '0';
 						}
 						break;
+#endif
 #ifdef HDIO_SET_DMA
 					case 'd':
 						get_dma = noisy;
@@ -1732,6 +1898,7 @@
 						GET_STRING(set_piomode,piomode);
 						break;
 #endif
+#ifdef BLKROGET
 					case 'r':
 						get_readonly = noisy;
 						noisy = 1;
@@ -1742,16 +1909,21 @@
 							readonly = *p++ - '0';
 						}
 						break;
+#endif
+#ifdef HDIO_SET_MULTCOUNT
 					case 'm':
 						get_mult = noisy;
 						noisy = 1;
 						GET_NUMBER(set_mult,mult);
 						break;
+#endif
+#ifdef HDIO_SET_32BIT
 					case 'c':
 						get_io32bit = noisy;
 						noisy = 1;
 						GET_NUMBER(set_io32bit,io32bit);
 						break;
+#endif
 #ifdef HDIO_DRIVE_CMD
 					case 's':
 						get_powerup_in_standby = noisy;
@@ -1776,6 +1948,7 @@
 						if (!set_defects)
 							fprintf(stderr, "-D: missing value\n");
 						break;
+#endif
 #ifdef CDROM_SELECT_SPEED
 					case 'E':
 						set_cdromspeed = 1;
@@ -1784,7 +1957,7 @@
 							fprintf (stderr, "-s: missing value\n");
 						break;
 #endif /* CDROM_SELECT_SPEED */
-
+#ifdef HDIO_DRIVE_CMD
 					case 'P':
 						get_prefetch = noisy;
 						noisy = 1;
@@ -1865,11 +2038,13 @@
 						noisy = 1;
 						set_sleepnow = 1;
 						break;
-
+#endif /* HDIO_DRIVE_CMD */
+#ifdef BLKRRPART
 					case 'z':
 						reread_partn = 1;
 						break;
-
+#endif
+#ifdef HDIO_DRIVE_CMD
 					case 'Z':
 						get_seagate = noisy;
 						noisy = 1;
@@ -1971,23 +2146,33 @@
 						break;
 
 #endif /* HDIO_TRISTATE_HWIF */
+#ifdef BLKRASET
 					case 'a':
 						get_fsreadahead = noisy;
 						noisy = 1;
 						GET_NUMBER(set_fsreadahead,fsreadahead);
 						break;
+#endif
+#ifdef HDIO_DRIVE_CMD
 					case 'B':
 						get_apmmode = noisy;
 						noisy = 1;
 						GET_NUMBER(set_apmmode,apmmode);
 						if (!set_apmmode)
-						printf("-B: missing value (1-255)\n");
+							printf("-B: missing value (1-255)\n");
 						break;
+#endif /* HDIO_DRIVE_CMD */
 					case 't':
+						GET_NUMBER(do_timings,timings);
+						if (!do_timings)
+							timings = 3.0;
 						do_timings = 1;
 						do_flush = 1;
 						break;
 					case 'T':
+						GET_NUMBER(do_ctimings,ctimings);
+						if (!do_ctimings)
+							ctimings = 2.0;
 						do_ctimings = 1;
 						do_flush = 1;
 						break;
@@ -2019,17 +2204,19 @@
 					case 'h':
 						usage_error(0);
 						break;
-#if defined(WIN_SECURITY_FREEZE_LOCK) && defined(IDE_DRIVE_TASK_NO_DATA)
+#if defined(WIN_SECURITY_FREEZE_LOCK) && defined(HDIO_DRIVE_CMD)
 					case '-':
 						p1 = p;		//Save Switch-String
 						while (isgraph(*p))
 							p++;	//Move P forward
-						if (0 == strcmp(p1, "security-help")) {
+						if (0 == strcmp(p1, "security-freeze")) {
+							set_freeze = 1;
+						}
+#if defined(WIN_SECURITY_SET_PASS) && defined(IDE_DRIVE_TASK_NO_DATA)
+						else if (0 == strcmp(p1, "security-help")) {
 							security_help();
 							if (!argc)
 								exit(0);
-						} else if (0 == strcmp(p1, "security-freeze")) {
-							set_freeze = 1;
 						} else if (0 == strcmp(p1, "security-unlock")) {
 							open_flags = O_RDWR;
 							set_security = 1;
@@ -2070,11 +2257,13 @@
 							if (*p == 'u') /* user */
 								security_master = 0;
 							++p;
-						} else {
+						}
+#endif // defined(WIN_SECURITY_SET_PASS) && defined(IDE_DRIVE_TASK_NO_DATA)
+						else {
 							usage_error(1);
 						}
 						break;
-#endif // defined(WIN_SECURITY_FREEZE_LOCK) && defined(IDE_DRIVE_TASK_NO_DATA)
+#endif // defined(WIN_SECURITY_FREEZE_LOCK) && defined(HDIO_DRIVE_CMD)
 					default:
 						usage_error(1);
 				}
diff -uNr hdparm-6.9.orig/hdparm.h hdparm-6.9/hdparm.h
--- hdparm-6.9.orig/hdparm.h	2006-04-28 16:33:01.000000000 +0200
+++ hdparm-6.9/hdparm.h	2007-02-28 22:00:59.000000000 +0100
@@ -1,6 +1,21 @@
 /* Some prototypes for extern functions. */
 
+#if !defined(_WIN32) && !defined(__CYGWIN__)
 #include <linux/types.h>	/* for __u16 */
+typedef unsigned long long __ull;
+#else
+typedef unsigned char    __u8;
+typedef unsigned short   __u16;
+typedef unsigned long    __u32;
+#ifndef _MSC_VER
+typedef unsigned long long __u64;
+typedef unsigned long long __ull;
+#else
+typedef unsigned __int64 __u64;
+typedef unsigned __int64 __ull;
+#endif
+#endif
+
 
 #if !defined(__GNUC__) && !defined(__attribute__)
 #define __attribute__(x)	/* if not using GCC, turn off the __attribute__
diff -uNr hdparm-6.9.orig/identify.c hdparm-6.9/identify.c
--- hdparm-6.9.orig/identify.c	2006-10-16 19:10:53.000000000 +0200
+++ hdparm-6.9/identify.c	2007-02-28 22:00:59.000000000 +0100
@@ -2,6 +2,7 @@
 #include <stdlib.h>
 #include <errno.h>
 #include <string.h>
+#if !defined(_WIN32) && !defined(__CYGWIN__)
 #include <linux/types.h>
 #include <endian.h>
 
@@ -10,6 +11,7 @@
 #endif
 
 #include <unistd.h>
+#endif
 #include "hdparm.h"
 
 /* device types */
@@ -507,6 +509,11 @@
 __u8 mode_loop(__u16 mode_sup, __u16 mode_sel, int cc, __u8 *have_mode);
 void print_ascii(__u16 *p, __u8 length);
 
+#ifdef _MSC_VER
+#define abs(x) ((__int64)(x) >= 0 ? (__int64)(x) : -(__int64)(x))
+#endif
+
+
 // Given a known-supported ATA major revision,
 // return the lowest possible supported ATA revision.
 // Each new revision seems to (sometimes) obsolete one
@@ -669,16 +676,31 @@
 	printf("Standards:");
 	if(eqpt != CDROM) {
 		//printf("major=%04x minor=%04x\n", val[MAJOR], val[MINOR]);
+		const char * used = 0;
 		if(val[MINOR] && (val[MINOR] <= MINOR_MAX)) {
 			if(like_std < 3)
 				like_std = 3;
 			std = actual_ver[val[MINOR]];
 			if (std)
-				printf("\n\tUsed: %s ",minor_str[val[MINOR]]);
-		} else if (val[MINOR] == 0x107) {
-			std = 8;
-			printf("\n\tUsed: %s ", "ATA8-ACS revision 2d");
+				used = minor_str[val[MINOR]];
+		} else {
+			/* check for recent ATA-8 revision codes (not added to
+			 * actual_ver/minor_str to avoid large sparse tables) */
+			switch (val[MINOR]) {
+			  case 0x0027: used = "ATA-8-ACS revision 3c"; break;
+			  case 0x0033: used = "ATA-8-ACS revision 3e"; break;
+			  case 0x0042: used = "ATA-8-ACS revision 3f"; break;
+			  case 0x0052: used = "ATA-8-ACS revision 3b"; break;
+			  case 0x0107: used = "ATA-8-ACS revision 2d"; break;
+			}
+			if (used)
+				std = 8;
 		}
+		if (used)
+			printf("\n\tUsed: %s ", used);
+		else if (val[MINOR] >= 0x001f) /* first "reserved" value possibly later used by ATA-8 */
+			printf("\n\tUsed: unknown (minor revision code 0x%04x) ", val[MINOR]);
+
 		/* looks like when they up-issue the std, they obsolete one;
 		 * thus, only the newest 4 issues need be supported.
 		 * (That's what "kk" and "min_std" are all about) */
@@ -706,7 +728,10 @@
 		 * the words from the next level up.  It happens.
 		 */
 		if(like_std < std) like_std = std;
-		if(((std == 5) || (!std && (like_std < 6))) &&
+		if(((std == 7) || (!std && (like_std < 8))) &&
+		   (val[SCT_SUPP] & 0x1)) {
+			like_std = 8;
+		} else if(((std == 5) || (!std && (like_std < 6))) &&
 		   ( (((val[CMDS_SUPP_1] & VALID) == VALID_VAL) &&
 		     ((val[CMDS_SUPP_1] & CMDS_W83) > 0x00ff)) ||
 		    (((val[CMDS_SUPP_2] & VALID) == VALID_VAL) &&
@@ -820,27 +845,27 @@
 					if(abs(mm - bb) > abs(nn - bb))
 						mm = nn;
 				}
-				printf("\tCHS current addressable sectors:%11u\n",mm);
+				printf("\tCHS current addressable sectors:%11u\n",(unsigned)mm);
 			} 
 		}
 		if (val[CAPAB_0] & LBA_SUP) {
 		/* LBA addressing */
-			printf("\tLBA    user addressable sectors:%11u\n",ll);
+			printf("\tLBA    user addressable sectors:%11u\n",(unsigned)ll);
 			if( ((val[CMDS_SUPP_1] & VALID) == VALID_VAL) &&
 			     (val[CMDS_SUPP_1] & SUPPORT_48_BIT) ) {
 				bbbig = (__u64)val[LBA_64_MSB] << 48 | 
 				        (__u64)val[LBA_48_MSB] << 32 |
 				        (__u64)val[LBA_MID] << 16 | 
 					val[LBA_LSB] ;
-				printf("\tLBA48  user addressable sectors:%11llu\n", (unsigned long long)bbbig);
+				printf("\tLBA48  user addressable sectors:%11llu\n", (__ull)bbbig);
 			}
 		}
 		if (!bbbig) bbbig = (__u64)(ll>mm ? ll : mm); /* # 512 byte blocks */
 		if (!bbbig) bbbig = bb;
-		printf("\tdevice size with M = 1024*1024: %11llu MBytes\n", (unsigned long long)(bbbig>>11));
+		printf("\tdevice size with M = 1024*1024: %11llu MBytes\n", (__ull)(bbbig>>11));
 		bbbig = (bbbig<<9)/1000000;
-		printf("\tdevice size with M = 1000*1000: %11llu MBytes ", (unsigned long long)bbbig);
-		if(bbbig > 1000) printf("(%llu GB)\n", (unsigned long long)(bbbig/1000));
+		printf("\tdevice size with M = 1000*1000: %11llu MBytes ", (__ull)bbbig);
+		if(bbbig > 1000) printf("(%llu GB)\n", (__ull)(bbbig/1000));
 		else printf("\n");
 
 	}
@@ -1153,7 +1178,7 @@
 		/* some older devices have NULLs */
 		c = (*p) >> 8;
 		if (c) putchar(c);
-		c = (*p);
+		c = (unsigned char)(*p);
 		if (c) putchar(c);
 		p++;
 	}
diff -uNr hdparm-6.9.orig/win32/Changelog.win32 hdparm-6.9/win32/Changelog.win32
--- hdparm-6.9.orig/win32/Changelog.win32	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/Changelog.win32	2007-02-28 22:18:08.000000000 +0100
@@ -0,0 +1,23 @@
+hdparm-6.9-20070228
+    - Cygwin port (patch 1668007)
+    - added /dev/sd[a-z] device names
+hdparm-6.9-20070224
+    - added identify of recent ATA-8 minor revisions (patch 1667900)
+    - added optional test duration argument to -t and -T (patch 1593726)
+hdparm-6.9-20061030
+    - merged with hdparm-6.9
+      - added SCT feature set (patch 1577615)
+      - added '-s' to control power-up in standby (patch 1579209)
+    - fixed .TP in man page (patch 1586652)
+    - fixed parameter passing of SET_FEATURES commands (-B, -M, -S)
+    - added get acoustic (-M)
+    - added --direct
+hdparm-6.6-20060901
+    - IDE+SMART ioctl for Win2000, XP<SP2 compatibility
+    - added --security-freeze
+    - device reset (-w)
+    - check power mode (-C)
+hdparm-6.6-20060818
+    - first windows prototype based on hdparm-6.6
+
+Christian Franke (chrfranke@users.sourceforge.net)
diff -uNr hdparm-6.9.orig/win32/LICENSE.win32.txt hdparm-6.9/win32/LICENSE.win32.txt
--- hdparm-6.9.orig/win32/LICENSE.win32.txt	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/LICENSE.win32.txt	2007-02-28 22:01:44.000000000 +0100
@@ -0,0 +1,14 @@
+BSD-Style Open Source License:
+
+You may freely use, modify, and redistribute the hdparm program,
+as either binary or source, or both.
+
+The only condition is that my name and copyright notice
+remain in the source code as-is.
+
+Mark Lord (mlord@pobox.com)
+
+--
+Same condition applies to the Windows-specific code.
+
+Christian Franke (chrfranke@users.sourceforge.net)
diff -uNr hdparm-6.9.orig/win32/Makefile.cygwin hdparm-6.9/win32/Makefile.cygwin
--- hdparm-6.9.orig/win32/Makefile.cygwin	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/Makefile.cygwin	2007-02-28 22:01:25.000000000 +0100
@@ -0,0 +1,51 @@
+# Makefile for hdparm for Cygwin
+
+srcdir = ..
+VPATH = $(srcdir):$(srcdir)/win32
+
+DESTDIR =
+
+binprefix = /usr
+manprefix = /usr
+exec_prefix = $(binprefix)/
+sbindir = $(exec_prefix)sbin
+mandir = $(manprefix)/share/man
+oldmandir = $(manprefix)/man
+
+CC = gcc
+CFLAGS = -O2 -W -Wall
+
+LDFLAGS = -s
+INSTALL = install
+INSTALL_DATA = $(INSTALL) -m 644
+INSTALL_DIR = $(INSTALL) -m 755 -d
+INSTALL_PROGRAM = $(INSTALL)
+
+all: hdparm
+
+hdparm.o: hdparm.h fs.h hdreg.h rawio.h shm.h version.h
+
+identify.o: hdparm.h
+
+rawio.o: rawio.h fs.h hdreg.h 
+
+shm.o: shm.h
+
+hdparm: hdparm.o identify.o rawio.o shm.o
+	$(CC) $(LDFLAGS) -o $@ hdparm.o identify.o rawio.o shm.o
+
+install: all hdparm.8
+	if [ ! -z $(DESTDIR) ]; then $(INSTALL_DIR) $(DESTDIR) ; fi
+	if [ ! -z $(DESTDIR)$(sbindir) ]; then $(INSTALL_DIR) $(DESTDIR)$(sbindir) ; fi
+	if [ ! -z $(DESTDIR)$(mandir) ]; then $(INSTALL_DIR) $(DESTDIR)$(mandir) ; fi
+	if [ ! -z $(DESTDIR)$(mandir)/man8/ ]; then $(INSTALL_DIR) $(DESTDIR)$(mandir)/man8/ ; fi
+	if [ -f $(DESTDIR)$(sbindir)/hdparm ]; then rm -f $(DESTDIR)$(sbindir)/hdparm ; fi
+	if [ -f $(DESTDIR)$(mandir)/man8/hdparm.8 ]; then rm -f $(DESTDIR)$(mandir)/man8/hdparm.8 ;\
+	elif [ -f $(DESTDIR)$(oldmandir)/man8/hdparm.8 ]; then rm -f $(DESTDIR)$(oldmandir)/man8/hdparm.8 ; fi
+	$(INSTALL_PROGRAM) -D hdparm $(DESTDIR)$(sbindir)/hdparm
+	if [ -d $(DESTDIR)$(mandir) ]; then $(INSTALL_DATA) -D $(srcdir)/hdparm.8 $(DESTDIR)$(mandir)/man8/hdparm.8 ;\
+	elif [ -d $(DESTDIR)$(oldmandir) ]; then $(INSTALL_DATA) -D $(srcdir)/hdparm.8 $(DESTDIR)$(oldmandir)/man8/hdparm.8 ; fi
+
+clean:
+	rm -f hdparm.exe *.o
+
diff -uNr hdparm-6.9.orig/win32/Makefile.win32 hdparm-6.9/win32/Makefile.win32
--- hdparm-6.9.orig/win32/Makefile.win32	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/Makefile.win32	2007-02-28 21:50:41.000000000 +0100
@@ -0,0 +1,106 @@
+# Makefile for hdparm for Windows
+#
+# Requires Cygwin with mingw32 packages to build
+#
+
+VERSION= beta
+srcdir = ..
+VPATH = $(srcdir):$(srcdir)/win32
+
+CC = gcc -mno-cygwin
+CFLAGS = -O2 -W -Wall
+LDFLAGS = -s
+
+all: hdparm.exe hdparm.8.html hdparm.8.txt
+
+hdparm.o: hdparm.h fs.h hdreg.h timer.h shm.h rawio.h version.h
+
+identify.o: hdparm.h
+
+rawio.o: rawio.h fs.h hdreg.h 
+
+shm.o: shm.h
+
+timer.o: timer.h
+
+hdparm.exe: hdparm.o identify.o rawio.o shm.o timer.o
+	$(CC) $(LDFLAGS) -o $@ hdparm.o identify.o rawio.o shm.o timer.o
+
+hdparm.8.html: $(srcdir)/hdparm.8
+	man2html $(srcdir)/hdparm.8 | sed 1d > hdparm.8.html
+
+hdparm.8.txt: $(srcdir)/hdparm.8
+	groff -man -Tascii -P'-bcou' < $(srcdir)/hdparm.8 > hdparm.8.txt
+
+clean:
+	rm -f hdparm.exe *.o hdparm.8.html hdparm.8.txt
+
+
+# Build binary distribution
+
+distdir  = hdparm-$(VERSION).win32
+distzip  = hdparm-$(VERSION).win32.zip
+distinst = hdparm-$(VERSION).win32-setup.exe
+
+
+distdep= hdparm.exe hdparm.8.html
+
+distfiles= \
+	$(distdir)/bin/hdparm.exe \
+	$(distdir)/doc/hdparm.8.html \
+	$(distdir)/doc/hdparm.8.txt \
+	$(distdir)/doc/Changelog.txt \
+	$(distdir)/doc/Changelog.win32.txt \
+	$(distdir)/doc/LICENSE.win32.txt \
+	$(distdir)/doc/README.acoustic.txt
+
+$(distdir)/bin/hdparm.exe: hdparm.exe
+	cp -p $< $@
+
+$(distdir)/doc/%: ./%
+	unix2dos < $< > $@
+	touch -r $< $@
+
+$(distdir)/doc/%.txt: ./%
+	unix2dos < $< > $@
+	touch -r $< $@
+
+$(distdir)/doc/%.txt: ../%
+	unix2dos < $< > $@
+	touch -r $< $@
+
+distzip: $(distzip)
+
+distinst: $(distinst)
+
+distdir: distdir.mkdir $(distfiles)
+
+install: $(distinst)
+	./$(distinst)
+
+$(distzip): distdir.mkdir $(distfiles)
+	@rm -fv $(distzip)
+	cd $(distdir) && zip -9Dr ../$(distzip) .
+
+$(distinst): installer.nsi distdir.mkdir $(distfiles)
+	@makensis="$(MAKENSIS)"; if [ -z "$$makensis" ]; then \
+	  if [ ! -z "$$PROGRAMFILES" ] && "$$PROGRAMFILES/NSIS/makensis" /VERSION >/dev/null 2>&1; then \
+	    makensis="$$PROGRAMFILES/NSIS/makensis"; \
+	  elif makensis /VERSION >/dev/null 2>&1; then \
+	    makensis=makensis; \
+	  else \
+	    echo 'makensis: command not found. Please download and install NSIS' 1>&2; \
+	    echo 'from http://nsis.sourceforge.net/Download' 1>&2; exit 1; \
+	  fi; \
+	fi; \
+	echo "$$makensis /V2 /NOCD /DINPDIR=$(distdir) /DOUTFILE=$(distinst) $(srcdir)/win32/installer.nsi"; \
+	"$$makensis" /V2 /NOCD /DINPDIR="$(distdir)" /DOUTFILE="$(distinst)" $(srcdir)/win32/installer.nsi
+
+distdir.mkdir:
+	@test -d $(distdir)/bin || mkdir -pv $(distdir)/bin
+	@test -d $(distdir)/doc || mkdir -pv $(distdir)/doc
+	touch $@
+
+cleandist:
+	rm -rf $(distdir) distdir.mkdir
+
diff -uNr hdparm-6.9.orig/win32/fs.h hdparm-6.9/win32/fs.h
--- hdparm-6.9.orig/win32/fs.h	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/fs.h	2006-08-17 21:39:22.000000000 +0200
@@ -0,0 +1,15 @@
+/* win32/fs.h */
+
+/*
+#define BLKROSET        0x00125d
+#define BLKROGET        0x00125e
+#define BLKRRPART       0x00125f
+*/
+#define BLKGETSIZE      0x001260
+/*
+#define BLKFLSBUF       0x001261
+#define BLKRASET        0x001262
+#define BLKRAGET        0x001262
+*/
+#define BLKGETSIZE64    0x041268
+
diff -uNr hdparm-6.9.orig/win32/hdreg.h hdparm-6.9/win32/hdreg.h
--- hdparm-6.9.orig/win32/hdreg.h	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/hdreg.h	2006-10-30 22:51:37.000000000 +0100
@@ -0,0 +1,160 @@
+/* win32/hdreg.h */
+
+#define WIN_SETIDLE1            0xE3
+#define WIN_DOORLOCK            0xDE
+#define WIN_DOORUNLOCK          0xDF
+#define WIN_IDENTIFY            0xEC
+#define WIN_PIDENTIFY           0xA1
+#define WIN_SETFEATURES         0xEF
+#define WIN_CHECKPOWERMODE1     0xE5
+#define WIN_CHECKPOWERMODE2     0x98
+
+
+#define HDIO_GETGEO             0x0301
+/*
+#define HDIO_GET_UNMASKINTR     0x0302
+#define HDIO_GET_MULTCOUNT      0x0304
+#define HDIO_GET_QDMA           0x0305
+#define HDIO_GET_KEEPSETTINGS   0x0308
+#define HDIO_GET_32BIT          0x0309
+#define HDIO_GET_NOWERR         0x030a
+#define HDIO_GET_DMA            0x030b
+#define HDIO_GET_NICE           0x030c
+*/
+#define HDIO_GET_IDENTITY       0x030d
+/*
+#define HDIO_GET_WCACHE         0x030e
+*/
+#define HDIO_GET_ACOUSTIC       0x030f
+/*
+#define HDIO_GET_BUSSTATE       0x031a
+#define HDIO_TRISTATE_HWIF      0x031b
+*/
+#define HDIO_DRIVE_RESET        0x031c
+/*
+#define HDIO_DRIVE_TASKFILE     0x031d
+#define HDIO_DRIVE_TASK         0x031e
+*/
+#define HDIO_DRIVE_CMD          0x031f
+/*
+#define HDIO_SET_MULTCOUNT      0x0321
+#define HDIO_SET_UNMASKINTR     0x0322
+#define HDIO_SET_KEEPSETTINGS   0x0323
+#define HDIO_SET_32BIT          0x0324
+#define HDIO_SET_NOWERR         0x0325
+#define HDIO_SET_DMA            0x0326
+#define HDIO_SET_PIO_MODE       0x0327
+#define HDIO_SCAN_HWIF          0x0328
+#define HDIO_SET_NICE           0x0329
+#define HDIO_UNREGISTER_HWIF    0x032a
+#define HDIO_SET_WCACHE         0x032b
+#define HDIO_SET_ACOUSTIC       0x032c
+#define HDIO_SET_BUSSTATE       0x032d
+#define HDIO_SET_QDMA           0x032e
+*/
+#define HDIO_GETGEO_BIG         0x0330
+
+
+#ifdef HDIO_GET_BUSSTATE
+enum {
+	BUSSTATE_OFF = 0,
+	BUSSTATE_ON,
+	BUSSTATE_TRISTATE
+};
+#endif
+
+#ifdef HDIO_GETGEO
+struct hd_geometry {
+	unsigned char heads;
+	unsigned char sectors;
+	unsigned short cylinders;
+	unsigned long start;
+};
+#endif
+
+#ifdef HDIO_GETGEO_BIG
+struct hd_big_geometry {
+	unsigned char heads;
+	unsigned char sectors;
+	unsigned int cylinders;
+	unsigned long start;
+};
+#endif
+
+#ifdef HDIO_GET_IDENTITY
+#define __NEW_HD_DRIVE_ID
+struct hd_driveid {
+	unsigned short config;
+	unsigned short cyls;
+	unsigned short reserved2;
+	unsigned short heads;
+	unsigned short track_bytes;
+	unsigned short sector_bytes;
+	unsigned short sectors;
+	unsigned short vendor0;
+	unsigned short vendor1;
+	unsigned short vendor2;
+	unsigned char  serial_no[20];
+	unsigned short buf_type;
+	unsigned short buf_size;
+	unsigned short ecc_bytes;
+	unsigned char  fw_rev[8];
+	unsigned char  model[40];
+	unsigned char  max_multsect;
+	unsigned char  vendor3;
+	unsigned short dword_io;
+	unsigned char  vendor4;
+	unsigned char  capability;
+	unsigned short reserved50;
+	unsigned char  vendor5;
+	unsigned char  tPIO;
+	unsigned char  vendor6;
+	unsigned char  tDMA;
+	unsigned short field_valid;
+	unsigned short cur_cyls;
+	unsigned short cur_heads;
+	unsigned short cur_sectors;
+	unsigned short cur_capacity0;
+	unsigned short cur_capacity1;
+	unsigned char  multsect;
+	unsigned char  multsect_valid;
+	unsigned int   lba_capacity;
+	unsigned short dma_1word;
+	unsigned short dma_mword;
+	unsigned short eide_pio_modes;
+	unsigned short eide_dma_min;
+	unsigned short eide_dma_time;
+	unsigned short eide_pio;
+	unsigned short eide_pio_iordy;
+	unsigned short words69_70[2];
+	unsigned short words71_74[4];
+	unsigned short queue_depth;
+	unsigned short words76_79[4];
+	unsigned short major_rev_num;
+	unsigned short minor_rev_num;
+	unsigned short command_set_1;
+	unsigned short command_set_2;
+	unsigned short cfsse;
+	unsigned short cfs_enable_1;
+	unsigned short cfs_enable_2;
+	unsigned short csf_default;
+	unsigned short dma_ultra;
+	unsigned short word89;
+	unsigned short word90;
+	unsigned short CurAPMvalues;
+	unsigned short word92;
+	unsigned short hw_config;
+	unsigned short words94_125[32];
+	unsigned short last_lun;
+	unsigned short word127;
+	unsigned short dlf;
+	unsigned short csfo;
+	unsigned short words130_155[26];
+	unsigned short word156;
+	unsigned short words157_159[3];
+	unsigned short words160_255[95];
+};
+
+typedef char ASSERT_SIZEOF_HD_DRIVE_ID[sizeof(struct hd_driveid)==512];
+#endif // HDIO_GET_IDENTITY
+
diff -uNr hdparm-6.9.orig/win32/installer.nsi hdparm-6.9/win32/installer.nsi
--- hdparm-6.9.orig/win32/installer.nsi	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/installer.nsi	2006-10-30 23:39:12.000000000 +0100
@@ -0,0 +1,347 @@
+;
+; installer.nsi - NSIS install script for hdparm
+;
+; Copyright (C) 2006 Christian Franke
+;
+; Download and install NSIS from: http://nsis.sourceforge.net/Download
+; Process with makensis to create installer (tested with NSIS 2.18).
+;
+
+
+;--------------------------------------------------------------------
+; Command line arguments:
+; makensis /DINPDIR=<input-dir> /DOUTFILE=<output-file> installer.nsi
+
+!ifndef INPDIR
+  !define INPDIR "."
+!endif
+
+!ifndef OUTFILE
+  !define OUTFILE "hdparm.win32-setup.exe"
+!endif
+
+;--------------------------------------------------------------------
+; General
+
+Name "hdparm"
+OutFile "${OUTFILE}"
+
+SetCompressor /solid lzma
+
+XPStyle on
+InstallColors /windows
+
+InstallDir "$PROGRAMFILES\hdparm"
+InstallDirRegKey HKLM "Software\hdparm" "Install_Dir"
+
+LicenseData "${INPDIR}\doc\LICENSE.win32.txt"
+
+;--------------------------------------------------------------------
+; Pages
+
+Page license
+Page components
+Page directory
+Page instfiles
+
+UninstPage uninstConfirm
+UninstPage instfiles
+
+InstType "Full"
+InstType "Extract files only"
+
+
+;--------------------------------------------------------------------
+; Sections
+
+Section "Program file"
+
+  SectionIn 1 2
+
+  SetOutPath "$INSTDIR\bin"
+  File "${INPDIR}\bin\hdparm.exe"
+
+SectionEnd
+
+Section "Documentation"
+
+  SectionIn 1 2
+
+  SetOutPath "$INSTDIR\doc"
+  File "${INPDIR}\doc\Changelog.txt"
+  File "${INPDIR}\doc\Changelog.win32.txt"
+  File "${INPDIR}\doc\LICENSE.win32.txt"
+  File "${INPDIR}\doc\README.acoustic.txt"
+  File "${INPDIR}\doc\hdparm.8.html"
+  File "${INPDIR}\doc\hdparm.8.txt"
+
+SectionEnd
+
+Section "Uninstaller"
+
+  SectionIn 1
+  AddSize 35
+
+  CreateDirectory "$INSTDIR"
+
+  ; Save installation location
+  WriteRegStr HKLM "Software\hdparm" "Install_Dir" "$INSTDIR"
+
+  ; Write uninstall keys and program
+  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\hdparm" "DisplayName" "hdparm"
+  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\hdparm" "UninstallString" '"$INSTDIR\uninst-hdparm.exe"'
+  WriteRegDWORD HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\hdparm" "NoModify" 1
+  WriteRegDWORD HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\hdparm" "NoRepair" 1
+  WriteUninstaller "uninst-hdparm.exe"
+
+SectionEnd
+
+Section "Start Menu Shortcuts"
+
+  SectionIn 1
+
+  CreateDirectory "$SMPROGRAMS\hdparm"
+
+  IfFileExists "$INSTDIR\bin\hdparm.exe" 0 nobin
+    SetOutPath "$INSTDIR\bin"
+    DetailPrint "Create file: $INSTDIR\bin\hdparm-run.bat"
+    FileOpen $0 "$INSTDIR\bin\hdparm-run.bat" "w"
+    FileWrite $0 "@echo off$\r$\necho hdparm %1 %2 %3 %4 %5$\r$\nhdparm %1 %2 %3 %4 %5$\r$\npause$\r$\n"
+    FileClose $0
+    CreateDirectory "$SMPROGRAMS\hdparm\hdparm Examples"
+    CreateShortCut "$SMPROGRAMS\hdparm\hdparm Examples\Show supported hdparm commands (-h).lnk"    "$INSTDIR\bin\hdparm-run.bat" "-h"
+    CreateShortCut "$SMPROGRAMS\hdparm\hdparm Examples\Identify 1st disk (-I hda).lnk"             "$INSTDIR\bin\hdparm-run.bat" "-I hda"
+    CreateShortCut "$SMPROGRAMS\hdparm\hdparm Examples\Identify 2nd disk (-I hdb).lnk"             "$INSTDIR\bin\hdparm-run.bat" "-I hdb"
+    CreateShortCut "$SMPROGRAMS\hdparm\hdparm Examples\Identify 1st CD drive (-I scd0).lnk"        "$INSTDIR\bin\hdparm-run.bat" "-I scd0"
+    CreateShortCut "$SMPROGRAMS\hdparm\hdparm Examples\Check 2nd disk power status (-C hdb).lnk"   "$INSTDIR\bin\hdparm-run.bat" "-C hdb"
+    CreateShortCut "$SMPROGRAMS\hdparm\hdparm Examples\Set 2nd disk to standby (-y hdb).lnk"       "$INSTDIR\bin\hdparm-run.bat" "-y hdb"
+    CreateShortCut "$SMPROGRAMS\hdparm\hdparm Examples\Perform 2nd disk read timings (-t hdb).lnk" "$INSTDIR\bin\hdparm-run.bat" "-t hdb"
+    CreateShortCut "$SMPROGRAMS\hdparm\hdparm Examples\Security Freeze 1st disk (--security-freeze hda).lnk" "$INSTDIR\bin\hdparm-run.bat" "--security-freeze hda"
+    CreateShortCut "$SMPROGRAMS\hdparm\hdparm Examples\Security Freeze 2nd disk (--security-freeze hdb).lnk" "$INSTDIR\bin\hdparm-run.bat" "--security-freeze hdb"
+  nobin:
+
+  IfFileExists "$INSTDIR\doc\LICENSE.win32.txt" 0 nodoc
+    SetOutPath "$INSTDIR\doc"
+    CreateDirectory "$SMPROGRAMS\hdparm\Documentation"
+    CreateShortCut "$SMPROGRAMS\hdparm\Documentation\hdparm manual page (html).lnk" "$INSTDIR\doc\hdparm.8.html"
+    CreateShortCut "$SMPROGRAMS\hdparm\Documentation\hdparm manual page (txt).lnk"  "$INSTDIR\doc\hdparm.8.txt"
+    CreateShortCut "$SMPROGRAMS\hdparm\Documentation\Changelog.lnk"                 "$INSTDIR\doc\Changelog.txt"
+    CreateShortCut "$SMPROGRAMS\hdparm\Documentation\Changelog.win32.lnk"           "$INSTDIR\doc\Changelog.win32.txt"
+    CreateShortCut "$SMPROGRAMS\hdparm\Documentation\LICENSE.win32.lnk"             "$INSTDIR\doc\LICENSE.win32.txt"
+    CreateShortCut "$SMPROGRAMS\hdparm\Documentation\README.acoustic.lnk"           "$INSTDIR\doc\README.acoustic.txt"
+  nodoc:
+
+  CreateShortCut "$SMPROGRAMS\hdparm\hdparm Sourceforge Project Page.lnk" "http://sourceforge.net/projects/hdparm/"
+
+  ; Uninstall
+  IfFileExists "$INSTDIR\uninst-hdparm.exe" 0 +2
+    CreateShortCut "$SMPROGRAMS\hdparm\Uninstall hdparm.lnk" "$INSTDIR\uninst-hdparm.exe"
+
+SectionEnd
+
+Section "Add install dir to PATH" PATH_IDX
+
+  SectionIn 1
+
+  IfFileExists "$WINDIR\system32\cmd.exe" 0 +3
+    Push "$INSTDIR\bin"
+    Call AddToPath
+ 
+SectionEnd
+
+;--------------------------------------------------------------------
+
+Section "Uninstall"
+  
+  DeleteRegKey HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\hdparm"
+  DeleteRegKey HKLM "Software\hdparm"
+
+  Delete "$INSTDIR\bin\hdparm.exe"
+  Delete "$INSTDIR\bin\hdparm-run.bat"
+  Delete "$INSTDIR\doc\Changelog.txt"
+  Delete "$INSTDIR\doc\Changelog.win32.txt"
+  Delete "$INSTDIR\doc\LICENSE.win32.txt"
+  Delete "$INSTDIR\doc\README.acoustic.txt"
+  Delete "$INSTDIR\doc\hdparm.8.html"
+  Delete "$INSTDIR\doc\hdparm.8.txt"
+  Delete "$INSTDIR\uninst-hdparm.exe"
+
+  Delete "$SMPROGRAMS\hdparm\*.*"
+  Delete "$SMPROGRAMS\hdparm\Documentation\*.*"
+  Delete "$SMPROGRAMS\hdparm\hdparm Examples\*.*"
+
+  RMDir  "$SMPROGRAMS\hdparm\Documentation"
+  RMDir  "$SMPROGRAMS\hdparm\hdparm Examples"
+  RMDir  "$SMPROGRAMS\hdparm"
+  RMDir  "$INSTDIR\bin"
+  RMDir  "$INSTDIR\doc"
+  RMDir  "$INSTDIR"
+
+  ; Remove install dir from PATH
+  IfFileExists "$WINDIR\system32\cmd.exe" 0 +3
+    Push "$INSTDIR\bin"
+    Call un.RemoveFromPath
+
+  IfFileExists "$INSTDIR" 0 +2
+    MessageBox MB_OK "Note: $INSTDIR could not be removed."
+
+  IfFileExists "$SMPROGRAMS\hdparm" 0 +2
+    MessageBox MB_OK "Note: $SMPROGRAMS\hdparm could not be removed."
+
+SectionEnd
+
+;--------------------------------------------------------------------
+
+Function .onInit
+
+  IfFileExists "$WINDIR\system32\cmd.exe" +3 0
+    MessageBox MB_OK "Note: hdparm does not support Win9x/ME."
+    SectionSetText ${PATH_IDX} ""
+
+FunctionEnd
+
+
+;--------------------------------------------------------------------
+; Utility functions
+;
+; Based on example from:
+; http://nsis.sourceforge.net/Path_Manipulation
+;
+
+
+!include "WinMessages.nsh"
+
+; Registry Entry for environment (NT4,2000,XP)
+; All users:
+;!define Environ 'HKLM "SYSTEM\CurrentControlSet\Control\Session Manager\Environment"'
+; Current user only:
+!define Environ 'HKCU "Environment"'
+
+
+; AddToPath - Appends dir to PATH
+;   (does not work on Win9x/ME)
+;
+; Usage:
+;   Push "dir"
+;   Call AddToPath
+
+Function AddToPath
+  Exch $0
+  Push $1
+  Push $2
+  Push $3
+ 
+  ReadRegStr $1 ${Environ} "PATH"
+  Push "$1;"
+  Push "$0;"
+  Call StrStr
+  Pop $2
+  StrCmp $2 "" "" done
+  Push "$1;"
+  Push "$0\;"
+  Call StrStr
+  Pop $2
+  StrCmp $2 "" "" done
+ 
+  DetailPrint "Add to PATH: $0"
+  StrCpy $2 $1 1 -1
+  StrCmp $2 ";" 0 +2
+    StrCpy $1 $1 -1 ; remove trailing ';'
+  StrCmp $1 "" +2   ; no leading ';'
+    StrCpy $0 "$1;$0"
+  WriteRegExpandStr ${Environ} "PATH" $0
+  SendMessage ${HWND_BROADCAST} ${WM_WININICHANGE} 0 "STR:Environment" /TIMEOUT=5000
+ 
+done:
+  Pop $3
+  Pop $2
+  Pop $1
+  Pop $0
+FunctionEnd
+
+
+; RemoveFromPath - Removes dir from PATH
+;
+; Usage:
+;   Push "dir"
+;   Call RemoveFromPath
+ 
+Function un.RemoveFromPath
+  Exch $0
+  Push $1
+  Push $2
+  Push $3
+  Push $4
+  Push $5
+  Push $6
+ 
+  ReadRegStr $1 ${Environ} "PATH"
+  StrCpy $5 $1 1 -1
+  StrCmp $5 ";" +2
+    StrCpy $1 "$1;" ; ensure trailing ';'
+  Push $1
+  Push "$0;"
+  Call un.StrStr
+  Pop $2 ; pos of our dir
+  StrCmp $2 "" done
+
+  DetailPrint "Remove from PATH: $0"
+  StrLen $3 "$0;"
+  StrLen $4 $2
+  StrCpy $5 $1 -$4 ; $5 is now the part before the path to remove
+  StrCpy $6 $2 "" $3 ; $6 is now the part after the path to remove
+  StrCpy $3 "$5$6"
+  StrCpy $5 $3 1 -1
+  StrCmp $5 ";" 0 +2
+    StrCpy $3 $3 -1 ; remove trailing ';'
+  WriteRegExpandStr ${Environ} "PATH" $3
+  SendMessage ${HWND_BROADCAST} ${WM_WININICHANGE} 0 "STR:Environment" /TIMEOUT=5000
+
+done:
+  Pop $6
+  Pop $5
+  Pop $4
+  Pop $3
+  Pop $2
+  Pop $1
+  Pop $0
+FunctionEnd
+ 
+
+; StrStr - find substring in a string
+;
+; Usage:
+;   Push "this is some string"
+;   Push "some"
+;   Call StrStr
+;   Pop $0 ; "some string"
+ 
+!macro StrStr un
+Function ${un}StrStr
+  Exch $R1 ; $R1=substring, stack=[old$R1,string,...]
+  Exch     ;                stack=[string,old$R1,...]
+  Exch $R2 ; $R2=string,    stack=[old$R2,old$R1,...]
+  Push $R3
+  Push $R4
+  Push $R5
+  StrLen $R3 $R1
+  StrCpy $R4 0
+  ; $R1=substring, $R2=string, $R3=strlen(substring)
+  ; $R4=count, $R5=tmp
+  loop:
+    StrCpy $R5 $R2 $R3 $R4
+    StrCmp $R5 $R1 done
+    StrCmp $R5 "" done
+    IntOp $R4 $R4 + 1
+    Goto loop
+done:
+  StrCpy $R1 $R2 "" $R4
+  Pop $R5
+  Pop $R4
+  Pop $R3
+  Pop $R2
+  Exch $R1 ; $R1=old$R1, stack=[result,...]
+FunctionEnd
+!macroend
+!insertmacro StrStr ""
+!insertmacro StrStr "un."
diff -uNr hdparm-6.9.orig/win32/rawio.c hdparm-6.9/win32/rawio.c
--- hdparm-6.9.orig/win32/rawio.c	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/rawio.c	2007-02-28 22:02:19.000000000 +0100
@@ -0,0 +1,699 @@
+/* win32/rawio.c - ioctl() emulation module for hdparm for Windows        */
+/*               - by Christian Franke (C) 2006-7 -- freely distributable */
+
+#define RAWIO_INTERNAL
+#include "rawio.h"
+
+#include "fs.h"
+#include "hdreg.h"
+
+#include <stdio.h>
+#include <stddef.h> // offsetof()
+#include <string.h>
+#include <errno.h>
+#include <io.h>
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#if _MSC_VER >= 1400
+#define _WIN32_WINNT 0x0502
+#include <winioctl.h>
+#endif
+
+#ifndef INVALID_SET_FILE_POINTER
+#define INVALID_SET_FILE_POINTER ((DWORD)-1)
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef IOCTL_STORAGE_RESET_DEVICE
+#define IOCTL_STORAGE_RESET_DEVICE 0x2d5004
+#endif
+
+
+#ifndef IOCTL_DISK_GET_DRIVE_GEOMETRY
+#define IOCTL_DISK_GET_DRIVE_GEOMETRY 0x070000
+
+typedef enum _MEDIA_TYPE {
+	Unknown
+} MEDIA_TYPE;
+
+typedef struct _DISK_GEOMETRY {
+	LARGE_INTEGER Cylinders;
+	MEDIA_TYPE MediaType;
+	DWORD TracksPerCylinder;
+	DWORD SectorsPerTrack;
+	DWORD BytesPerSector;
+} DISK_GEOMETRY;
+
+#endif // IOCTL_DISK_GET_DRIVE_GEOMETRY
+
+typedef char ASSERT_SIZEOF_DISK_GEOMETRY[sizeof(DISK_GEOMETRY) == 24];
+
+
+#ifndef IOCTL_DISK_GET_LENGTH_INFO
+#define IOCTL_DISK_GET_LENGTH_INFO 0x07405c
+
+typedef struct _GET_LENGTH_INFORMATION {
+	LARGE_INTEGER Length;
+} GET_LENGTH_INFORMATION;
+
+#endif // IOCTL_DISK_GET_LENGTH_INFO
+
+typedef char ASSERT_SIZEOF_GET_LENGTH_INFORMATION[sizeof(GET_LENGTH_INFORMATION) == 8];
+
+
+#ifndef SMART_RCV_DRIVE_DATA
+
+typedef struct _IDEREGS {
+	UCHAR  bFeaturesReg;
+	UCHAR  bSectorCountReg;
+	UCHAR  bSectorNumberReg;
+	UCHAR  bCylLowReg;
+	UCHAR  bCylHighReg;
+	UCHAR  bDriveHeadReg;
+	UCHAR  bCommandReg;
+	UCHAR  bReserved;
+} IDEREGS;
+
+#endif // SMART_RCV_DRIVE_DATA
+
+typedef char ASSERT_SIZEOF_IDEREGS[sizeof(IDEREGS) == 8];
+
+
+#ifndef IOCTL_IDE_PASS_THROUGH
+#define IOCTL_IDE_PASS_THROUGH 0x04d028
+#endif
+
+#pragma pack(1)
+
+typedef struct _ATA_PASS_THROUGH {
+	IDEREGS IdeReg;
+	ULONG   DataBufferSize;
+	UCHAR   DataBuffer[1];
+} ATA_PASS_THROUGH;
+
+#pragma pack()
+
+typedef char ASSERT_SIZEOF_ATA_PASS_THROUGH[sizeof(ATA_PASS_THROUGH) == 12+1];
+
+
+#ifndef IOCTL_ATA_PASS_THROUGH
+#define IOCTL_ATA_PASS_THROUGH 0x04d02c
+
+typedef struct _ATA_PASS_THROUGH_EX {
+	USHORT  Length;
+	USHORT  AtaFlags;
+	UCHAR  PathId;
+	UCHAR  TargetId;
+	UCHAR  Lun;
+	UCHAR  ReservedAsUchar;
+	ULONG  DataTransferLength;
+	ULONG  TimeOutValue;
+	ULONG  ReservedAsUlong;
+	ULONG/*_PTR*/ DataBufferOffset;
+	UCHAR  PreviousTaskFile[8];
+	UCHAR  CurrentTaskFile[8];
+} ATA_PASS_THROUGH_EX;
+
+typedef char ASSERT_SIZEOF_ATA_PASS_THROUGH_EX[sizeof(ATA_PASS_THROUGH_EX) == 40];
+
+#define ATA_FLAGS_DRDY_REQUIRED 0x01
+#define ATA_FLAGS_DATA_IN       0x02
+#define ATA_FLAGS_DATA_OUT      0x04
+#define ATA_FLAGS_48BIT_COMMAND 0x08
+
+#endif //IOCTL_ATA_PASS_THROUGH
+
+#ifndef SMART_RCV_DRIVE_DATA
+#define SMART_RCV_DRIVE_DATA 0x07c088
+
+#pragma pack(1)
+
+typedef struct _SENDCMDINPARAMS {
+	ULONG  cBufferSize;
+	IDEREGS  irDriveRegs;
+	UCHAR  bDriveNumber;
+	UCHAR  bReserved[3];
+	ULONG  dwReserved[4];
+	UCHAR  bBuffer[1];
+} SENDCMDINPARAMS;
+
+typedef struct _DRIVERSTATUS {
+	UCHAR  bDriverError;
+	UCHAR  bIDEError;
+	UCHAR  bReserved[2];
+	ULONG  dwReserved[2];
+} DRIVERSTATUS;
+
+typedef struct _SENDCMDOUTPARAMS {
+	ULONG  cBufferSize;
+	DRIVERSTATUS  DriverStatus;
+	UCHAR  bBuffer[1];
+} SENDCMDOUTPARAMS;
+
+
+#pragma pack()
+#endif // SMART_RCV_DRIVE_DATA
+
+typedef char ASSERT_SIZEOF_SENDCMDINPARAMS [sizeof(SENDCMDINPARAMS)  == 32+1];
+typedef char ASSERT_SIZEOF_SENDCMDOUTPARAMS[sizeof(SENDCMDOUTPARAMS) == 16+1];
+
+
+/////////////////////////////////////////////////////////////////////////////
+
+int win32_debug;
+
+static void print_ide_regs(const IDEREGS * ri, const IDEREGS * ro)
+{
+	if (ri)
+		printf("   In : CMD=0x%02x, FR=0x%02x, SC=0x%02x, SN=0x%02x, CL=0x%02x, CH=0x%02x, SEL=0x%02x\n",
+			ri->bCommandReg, ri->bFeaturesReg, ri->bSectorCountReg, ri->bSectorNumberReg,
+			ri->bCylLowReg,  ri->bCylHighReg,  ri->bDriveHeadReg);
+	if (ro)
+		printf("   Out: STS=0x%02x,ERR=0x%02x, SC=0x%02x, SN=0x%02x, CL=0x%02x, CH=0x%02x, SEL=0x%02x\n",
+			ro->bCommandReg, ro->bFeaturesReg, ro->bSectorCountReg, ro->bSectorNumberReg,
+			ro->bCylLowReg,  ro->bCylHighReg,  ro->bDriveHeadReg);
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+
+static int ide_pass_through(HANDLE hdevice, IDEREGS * regs, void * data, unsigned datasize)
+{ 
+	unsigned int size = sizeof(ATA_PASS_THROUGH)-1 + datasize;
+	ATA_PASS_THROUGH * buf = (ATA_PASS_THROUGH *)VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);
+	DWORD num_out;
+	const unsigned char magic = 0xcf;
+
+	if (!buf) {
+		errno = ENOMEM;
+		return -1;
+	}
+
+	buf->IdeReg = *regs;
+	buf->DataBufferSize = datasize;
+	if (datasize)
+		buf->DataBuffer[0] = magic;
+
+	if (!DeviceIoControl(hdevice, IOCTL_IDE_PASS_THROUGH,
+		buf, size, buf, size, &num_out, NULL)) {
+		long err = GetLastError();
+		if (win32_debug) {
+			printf("  IOCTL_IDE_PASS_THROUGH failed, Error=%ld\n", err);
+			print_ide_regs(regs, NULL);
+		}
+		VirtualFree(buf, 0, MEM_RELEASE);
+		errno = ENOSYS;
+		return -1;
+	}
+
+	if (buf->IdeReg.bCommandReg/*Status*/ & 0x01) {
+		if (win32_debug) {
+			printf("  IOCTL_IDE_PASS_THROUGH command failed:\n");
+			print_ide_regs(regs, &buf->IdeReg);
+		}
+		VirtualFree(buf, 0, MEM_RELEASE);
+		errno = EIO;
+		return -1;
+	}
+
+	if (datasize) {
+		if (!(num_out == size && buf->DataBuffer[0] != magic)) {
+			if (win32_debug) {
+				printf("  IOCTL_IDE_PASS_THROUGH output data missing (%lu, %lu)\n",
+					num_out, buf->DataBufferSize);
+				print_ide_regs(regs, &buf->IdeReg);
+			}
+			VirtualFree(buf, 0, MEM_RELEASE);
+			errno = EIO;
+			return -1;
+		}
+		memcpy(data, buf->DataBuffer, datasize);
+	}
+
+	if (win32_debug) {
+		printf("  IOCTL_IDE_PASS_THROUGH succeeded, bytes returned: %lu (buffer %lu)\n",
+			num_out, buf->DataBufferSize);
+		print_ide_regs(regs, &buf->IdeReg);
+	}
+	*regs = buf->IdeReg;
+
+	VirtualFree(buf, 0, MEM_RELEASE);
+	return 0;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+
+static int ata_pass_through(HANDLE hdevice, IDEREGS * regs, void * data, int datasize)
+{ 
+	typedef struct {
+		ATA_PASS_THROUGH_EX apt;
+		ULONG Filler;
+		UCHAR ucDataBuf[512];
+	} ATA_PASS_THROUGH_EX_WITH_BUFFERS;
+
+	ATA_PASS_THROUGH_EX_WITH_BUFFERS ab;
+	IDEREGS * ctfregs;
+	unsigned int size;
+	DWORD num_out;
+	const unsigned char magic = 0xcf;
+
+	memset(&ab, 0, sizeof(ab));
+	ab.apt.Length = sizeof(ATA_PASS_THROUGH_EX);
+	//ab.apt.PathId = 0;
+	//ab.apt.TargetId = 0;
+	//ab.apt.Lun = 0;
+	ab.apt.TimeOutValue = 10;
+	size = offsetof(ATA_PASS_THROUGH_EX_WITH_BUFFERS, ucDataBuf);
+	ab.apt.DataBufferOffset = size;
+
+	if (datasize) {
+		if (!(data && 0 <= datasize && datasize <= (int)sizeof(ab.ucDataBuf))) {
+			errno = EINVAL;
+			return -1;
+		}
+		ab.apt.AtaFlags = ATA_FLAGS_DATA_IN;
+		ab.apt.DataTransferLength = datasize;
+		size += datasize;
+		ab.ucDataBuf[0] = magic;
+	}
+	else {
+		//ab.apt.AtaFlags = 0;
+		//ab.apt.DataTransferLength = 0;
+	}
+
+	ctfregs = (IDEREGS *)ab.apt.CurrentTaskFile;
+	*ctfregs = *regs;
+
+	if (!DeviceIoControl(hdevice, IOCTL_ATA_PASS_THROUGH,
+		&ab, size, &ab, size, &num_out, NULL)) {
+		long err = GetLastError();
+		if (win32_debug) {
+			printf("  IOCTL_ATA_PASS_THROUGH failed, Error=%ld\n", err);
+			print_ide_regs(regs, NULL);
+		}
+		errno = ENOSYS;
+		return -1;
+	}
+
+	if (ctfregs->bCommandReg/*Status*/ & 0x01) {
+		if (win32_debug) {
+			printf("  IOCTL_ATA_PASS_THROUGH command failed:\n");
+			print_ide_regs(regs, ctfregs);
+		}
+		*regs = *ctfregs;
+		errno = EIO;
+		return -1;
+	}
+
+	if (datasize)
+		memcpy(data, ab.ucDataBuf, datasize);
+
+	if (win32_debug) {
+		printf("  IOCTL_ATA_PASS_THROUGH succeeded, bytes returned: %lu\n", num_out);
+		print_ide_regs(regs, ctfregs);
+	}
+	*regs = *ctfregs;
+
+	return 0;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+
+static int smart_rcv_drive_data(HANDLE hdevice, IDEREGS * regs, void * data, unsigned datasize)
+{
+	SENDCMDINPARAMS inpar;
+	unsigned char outbuf[sizeof(SENDCMDOUTPARAMS)-1 + 512];
+	const SENDCMDOUTPARAMS * outpar;
+	DWORD num_out;
+
+	memset(&inpar, 0, sizeof(inpar));
+	inpar.irDriveRegs = *regs;
+	inpar.irDriveRegs.bDriveHeadReg = 0xA0;
+	//inpar.bDriveNumber = 0;
+	inpar.cBufferSize = 512;
+
+	if (datasize != 512) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	memset(&outbuf, 0, sizeof(outbuf));
+
+	if (!DeviceIoControl(hdevice, SMART_RCV_DRIVE_DATA, &inpar, sizeof(SENDCMDINPARAMS)-1,
+		outbuf, sizeof(SENDCMDOUTPARAMS)-1 + 512, &num_out, NULL)) {
+		long err = GetLastError();
+		if (win32_debug) {
+			printf("  SMART_RCV_DRIVE_DATA failed, Error=%ld\n", err);
+			print_ide_regs(regs, NULL);
+		}
+		errno = ENOSYS;
+		return -1;
+	}
+
+	outpar = (const SENDCMDOUTPARAMS *)outbuf;
+
+	if (outpar->DriverStatus.bDriverError || outpar->DriverStatus.bIDEError) {
+		if (win32_debug) {
+			printf("  SMART_RCV_DRIVE_DATA failed, DriverError=0x%02x, IDEError=0x%02x\n",
+				outpar->DriverStatus.bDriverError, outpar->DriverStatus.bIDEError);
+			print_ide_regs(regs, NULL);
+		}
+		errno = (!outpar->DriverStatus.bIDEError ? ENOSYS : EIO);
+		return -1;
+	}
+
+	memcpy(data, outpar->bBuffer, 512);
+
+	if (win32_debug) {
+		printf("  SMART_RCV_DRIVE_DATA suceeded, bytes returned: %lu (buffer %lu)\n",
+			num_out, outpar->cBufferSize);
+		print_ide_regs(regs, NULL);
+	}
+
+	return 0;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+
+static int try_ata_pass_through(HANDLE hdevice, IDEREGS * regs, void * data, int datasize)
+{
+	static char avail = 0x7;
+	int rc;
+	if (avail & 0x1) {
+		rc = ata_pass_through(hdevice, regs, data, datasize);
+		if (rc >= 0 || errno != ENOSYS)
+			return rc;
+		avail &= ~0x1;
+	}
+	if ((avail & 0x2) && datasize >= 0) {
+		rc = ide_pass_through(hdevice, regs, data, datasize);
+		if (rc >= 0 || errno != ENOSYS)
+			return rc;
+		avail &= ~0x2;
+	}
+	if ((avail & 0x4) && regs->bCommandReg == WIN_IDENTIFY) {
+		rc = smart_rcv_drive_data(hdevice, regs, data, datasize);
+		if (rc >= 0 || errno != ENOSYS)
+			return rc;
+		avail &= ~0x4;
+	}
+	if (win32_debug) {
+		printf("  No ATA PASS THROUGH I/O control available\n");
+		print_ide_regs(regs, NULL);
+	}
+	errno = ENOSYS;
+	return -1;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+
+static int get_disk_geometry(HANDLE h, DISK_GEOMETRY * geo)
+{
+	DWORD num_out;
+	if (!DeviceIoControl(h, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, geo, sizeof(*geo), &num_out, NULL)) {
+		long err = GetLastError();
+		if (win32_debug)
+			printf("  IOCTL_DISK_GET_DRIVE_GEOMETRY failed, Error=%ld\n", err);
+		errno = (err == ERROR_INVALID_FUNCTION ? ENOSYS : EIO);
+		return -1;
+	}
+	if (win32_debug)
+		printf("  IOCTL_DISK_GET_DRIVE_GEOMETRY succeeded, bytes returned: %lu\n", num_out);
+	return 0;
+}
+
+static __int64 get_disk_length(HANDLE h)
+{
+	DWORD num_out;
+	GET_LENGTH_INFORMATION li;
+	if (!DeviceIoControl(h, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &li, sizeof(li), &num_out, NULL)) {
+		long err = GetLastError();
+		if (win32_debug)
+			printf("  IOCTL_DISK_GET_LENGTH_INFO failed, Error=%ld\n", err);
+		errno = (err == ERROR_INVALID_FUNCTION ? ENOSYS : EIO);
+		return -1;
+	}
+	if (win32_debug)
+		printf("  IOCTL_DISK_GET_LENGTH_INFO succeeded, bytes returned: %lu\n", num_out);
+	return li.Length.QuadPart;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+
+static int reset_device(HANDLE h)
+{
+	DWORD num_out;
+	if (!DeviceIoControl(h, IOCTL_STORAGE_RESET_DEVICE, NULL, 0, NULL, 0, &num_out, NULL)) {
+		long err = GetLastError();
+		if (win32_debug)
+			printf("  IOCTL_STORAGE_RESET_DEVICE failed, Error=%ld\n", err);
+		errno = (err == ERROR_INVALID_FUNCTION || err == ERROR_NOT_SUPPORTED ? ENOSYS : EIO);
+		return -1;
+	}
+	if (win32_debug)
+		printf("  IOCTL_STORAGE_RESET_DEVICE succeeded\n");
+	return 0;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+
+static char is_cd = 0;
+
+int win32_open(const char * name, unsigned flags, unsigned perm)
+{
+	int len;
+	char drv[1+1] = "";
+	unsigned cdno = ~0;
+	int n1 = -1;
+	char path[50];
+	HANDLE h;
+	DWORD crflags;
+	(void)perm;
+
+	if (!strncmp("/dev/", name, 5))
+		name += 5;
+	len = strlen(name);
+	if (sscanf(name, "%*[hs]d%1[a-z]%n", drv, &n1) == 1 && n1 == len) {
+		sprintf(path, "\\\\.\\PhysicalDrive%d", drv[0] - 'a');
+		is_cd = 0;
+	}
+	else if (sscanf(name, "scd%u%n", &cdno, (n1=-1, &n1)) == 1 && n1 == len && cdno <= 15) {
+		sprintf(path, "\\\\.\\CdRom%u", cdno);
+		is_cd = 1;
+	}
+	else {
+		errno = EINVAL;
+		return -1;
+	}
+
+	crflags = (flags & O_DIRECT ? FILE_FLAG_NO_BUFFERING : 0);
+	if ((h = CreateFileA(path,
+		GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE,
+		NULL, OPEN_EXISTING, crflags, 0)) == INVALID_HANDLE_VALUE) {
+		long err = GetLastError();
+		if (win32_debug)
+			printf("%s: cannot open, Error=%ld\n", path, err);
+		if (err == ERROR_FILE_NOT_FOUND)
+			errno = ENOENT;
+		else if (err == ERROR_ACCESS_DENIED)
+			errno = EACCES;
+		else
+			errno = EIO;
+		return -1;
+	}
+
+	if (win32_debug)
+		printf("%s: successfully opened\n", path);
+
+	return (int)h;
+}
+
+
+int win32_close(int fd)
+{
+	CloseHandle((HANDLE)fd);
+	return 0;
+}
+
+
+int win32_read(int fd, char * buf, int size)
+{
+	DWORD num_read;
+	if (!ReadFile((HANDLE)fd, buf, size, &num_read, NULL)) {
+		errno = EIO;
+		return -1;
+	}
+	return num_read;
+}
+
+
+long win32_lseek(int fd, long offset, int where)
+{
+	DWORD pos;
+	if (where != SEEK_SET) {
+		errno = EINVAL;
+		return -1;
+	}
+	pos = SetFilePointer((HANDLE)fd, offset, 0, FILE_BEGIN);
+	if (pos == INVALID_SET_FILE_POINTER) {
+		errno = EIO;
+		return -1;
+	}
+	return pos;
+}
+
+
+static void fix_id_string(unsigned char * s, int n)
+{
+	int i;
+	for (i = 0; i < n-1; i+=2) {
+		unsigned char c = s[i]; s[i] = s[i+1]; s[i+1] = c;
+	}
+	for (i = n-1; i > 0 && s[i] == ' '; i--)
+		s[i] = 0;
+}
+
+
+int win32_ioctl(int fd, int code, void * arg)
+{
+	int rc = 0;
+
+	switch (code) {
+
+#ifdef BLKGETSIZE
+	  case BLKGETSIZE:
+	  case BLKGETSIZE64:
+		{
+			__int64 size = get_disk_length((HANDLE)fd);
+			if (size < 0 && errno == ENOSYS) {
+				DISK_GEOMETRY dg;
+				rc = get_disk_geometry((HANDLE)fd, &dg);
+				if (rc)
+					break;
+				size = dg.Cylinders.QuadPart * dg.TracksPerCylinder * dg.SectorsPerTrack * dg.BytesPerSector;
+			}
+			if (code == BLKGETSIZE)
+				*(unsigned *)arg = (unsigned)(size >> 9);
+			else
+				*(unsigned __int64 *)arg = size;
+		}
+		break;
+#endif
+
+#ifdef HDIO_GETGEO
+	  case HDIO_GETGEO:
+	  case HDIO_GETGEO_BIG:
+		{
+			DISK_GEOMETRY dg;
+			rc = get_disk_geometry((HANDLE)fd, &dg);
+			if (rc)
+				break;
+			if (code == HDIO_GETGEO) {
+				struct hd_geometry * gp = (struct hd_geometry *)arg;
+				gp->cylinders = (unsigned short)(dg.Cylinders.LowPart <= 0xffff ? dg.Cylinders.LowPart : 0xffff);
+				gp->heads = (unsigned char)(dg.TracksPerCylinder <= 0xff ? dg.TracksPerCylinder : 0xff);
+				gp->sectors = (unsigned char)(dg.SectorsPerTrack <= 0xff ? dg.SectorsPerTrack : 0xff);
+				gp->start = 0;
+			}
+			else {
+				struct hd_big_geometry * gp = (struct hd_big_geometry *)arg;
+				gp->cylinders = dg.Cylinders.LowPart;
+				gp->heads = (unsigned char)(dg.TracksPerCylinder <= 0xff ? dg.TracksPerCylinder : 0xff);
+				gp->sectors = (unsigned char)(dg.SectorsPerTrack <= 0xff ? dg.SectorsPerTrack : 0xff);
+				gp->start = 0;
+			}
+		}
+		break;
+#endif
+
+#ifdef HDIO_GET_IDENTITY
+	  case HDIO_GET_IDENTITY:
+		if (!arg) // Flush
+			break;
+		{
+			struct hd_driveid * id = (struct hd_driveid *)arg;
+			IDEREGS regs = {0,0,0,0,0,0,0,0};
+			regs.bCommandReg = (!is_cd ? WIN_IDENTIFY : WIN_PIDENTIFY);
+			regs.bSectorCountReg = 1;
+			rc = try_ata_pass_through((HANDLE)fd, &regs, id, 512);
+			if (rc)
+				break;
+			fix_id_string(id->model,     sizeof(id->model));
+			fix_id_string(id->fw_rev,    sizeof(id->fw_rev));
+			fix_id_string(id->serial_no, sizeof(id->serial_no));
+		}
+		break;
+#endif
+
+#ifdef HDIO_GET_ACOUSTIC
+	  case HDIO_GET_ACOUSTIC:
+		if (!arg) // Flush
+			break;
+		{
+			struct hd_driveid id;
+			IDEREGS regs = {0,0,0,0,0,0,0,0};
+			memset(&id, 0, sizeof(id));
+			regs.bCommandReg = (!is_cd ? WIN_IDENTIFY : WIN_PIDENTIFY);
+			regs.bSectorCountReg = 1;
+			rc = try_ata_pass_through((HANDLE)fd, &regs, &id, 512);
+			if (rc)
+				break;
+			*(long *)arg = (id.words94_125[0] & 0xff);
+		}
+		break;
+#endif
+
+#ifdef HDIO_DRIVE_RESET
+	  case HDIO_DRIVE_RESET:
+		rc = reset_device((HANDLE)fd);
+		break;
+#endif
+
+#ifdef HDIO_DRIVE_CMD
+	  case HDIO_DRIVE_CMD:
+		if (!arg) // Flush
+			break;
+		{
+			// input:
+			// [0]: COMMAND
+			// [1]: SECTOR NUMBER (SMART) or SECTOR COUNT (other)
+			// [2]: FEATURE
+			// [3]: SECTOR COUNT (transfer size)
+			// output:
+			// [0]: STATUS
+			// [1]: ERROR
+			// [2]: SECTOR COUNT
+			// [3]: (undefined?)
+			// [4...]: data
+			unsigned char * idebuf = (unsigned char *)arg;
+			IDEREGS regs = {0,0,0,0,0,0,0,0};
+			regs.bCommandReg             = idebuf[0];
+			regs.bFeaturesReg            = idebuf[2];
+			if (idebuf[3])
+				regs.bSectorCountReg = idebuf[3];
+			else
+				regs.bSectorCountReg = idebuf[1];
+			rc = try_ata_pass_through((HANDLE)fd, &regs, idebuf+4, idebuf[3] * 512);
+			idebuf[0] = regs.bCommandReg;  // STS
+			idebuf[1] = regs.bFeaturesReg; // ERR
+			idebuf[2] = regs.bSectorCountReg;
+		}
+		break;
+#endif
+
+	  default:
+		errno = ENOSYS;
+		rc = -1;
+		break;
+	}
+
+	return rc;
+}
diff -uNr hdparm-6.9.orig/win32/rawio.h hdparm-6.9/win32/rawio.h
--- hdparm-6.9.orig/win32/rawio.h	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/rawio.h	2007-02-28 22:02:19.000000000 +0100
@@ -0,0 +1,30 @@
+/* win32/rawio.h - ioctl() emulation module for hdparm for Windows        */
+/*               - by Christian Franke (C) 2006-7 -- freely distributable */
+
+int win32_open(const char * name, unsigned flags, unsigned perm);
+int win32_close(int fd);
+int win32_read(int fd, char * buf, int size);
+long win32_lseek(int fd, long offset, int where);
+int win32_ioctl(int fd, int code, void * arg);
+
+extern int win32_debug;
+
+#ifndef O_DIRECT
+#define O_DIRECT	040000
+#endif
+
+#ifndef ENOMSG
+#define ENOMSG		100
+#endif
+
+#ifndef RAWIO_INTERNAL
+
+#define open(name, flags)        win32_open(name, flags, 0666)
+#define close(fd)                win32_close(fd)
+#define read(fd, buf, size)      win32_read(fd, buf, size)
+#define lseek(fd, offset, where) win32_lseek(fd, offset, where)
+#define ioctl(fd, code, arg)     win32_ioctl(fd, code, (void*)(arg))
+#define fsync(fd) ((void)0)
+#define sync()    ((void)0)
+
+#endif
diff -uNr hdparm-6.9.orig/win32/shm.c hdparm-6.9/win32/shm.c
--- hdparm-6.9.orig/win32/shm.c	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/shm.c	2007-02-28 21:56:41.000000000 +0100
@@ -0,0 +1,41 @@
+/* win32/shm.c - shm*() emulation module for hdparm for Windows         */
+/*             - by Christian Franke (C) 2006-7 -- freely distributable */
+
+#include "shm.h"
+
+#include <errno.h>
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
+
+int shmget(int key, int size, int flags)
+{
+	char * addr;
+	(void)key; (void)flags;
+	addr = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);
+	if (!addr) {
+		errno = ENOMEM; return -1;
+	}
+	return (int)addr;
+}
+
+int shmctl(int id, int cmd, void *arg)
+{
+	(void)id; (void)cmd; (void)arg;
+	return 0;
+}
+
+void * shmat(int id, void *addr, int flags)
+{
+	(void)addr; (void)flags;
+	return (void *)id;
+}
+
+int shmdt(void * addr)
+{
+	if (!VirtualFree(addr, 0, MEM_RELEASE)) {
+		errno = EINVAL; return -1;
+	}
+	return 0;
+}
diff -uNr hdparm-6.9.orig/win32/shm.h hdparm-6.9/win32/shm.h
--- hdparm-6.9.orig/win32/shm.h	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/shm.h	2006-10-30 22:54:58.000000000 +0100
@@ -0,0 +1,12 @@
+/* win32/shm.h - shm*() emulation module for hdparm for Windows       */
+/*             - by Christian Franke (C) 2006 -- freely distributable */
+
+#define IPC_PRIVATE 0
+#define IPC_RMID    1
+#define SHM_LOCK    2
+
+int shmget(int key, int size, int flags);
+int shmctl(int id, int cmd, void *arg);
+void * shmat(int id, void *addr, int flags);
+int shmdt(void * addr);
+
diff -uNr hdparm-6.9.orig/win32/timer.c hdparm-6.9/win32/timer.c
--- hdparm-6.9.orig/win32/timer.c	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/timer.c	2007-02-28 21:56:41.000000000 +0100
@@ -0,0 +1,42 @@
+/* win32/timer.c - sleep/itimer emulation module for hdparm for Windows   */
+/*               - by Christian Franke (C) 2006-7 -- freely distributable */
+
+#include "timer.h"
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
+void sleep(int seconds)
+{
+	Sleep(seconds * 1000L);
+}
+
+
+static struct itimerval start_timerval;
+static __int64 start_walltime;
+
+int getitimer(int which, struct itimerval * val)
+{
+	FILETIME ft; __int64 wallnow, timernow, elapsed;
+	(void)which;
+	GetSystemTimeAsFileTime(&ft);
+	wallnow = (((__int64)ft.dwHighDateTime << 32) | ft.dwLowDateTime);
+	elapsed = (wallnow - start_walltime) / 10;
+	timernow = (__int64)start_timerval.it_value.tv_sec * 1000000 + start_timerval.it_value.tv_usec - elapsed;
+	if (timernow < 0)
+		timernow = 0;
+	val->it_value.tv_sec  = (long)(timernow / 1000000);
+	val->it_value.tv_usec = (long)(timernow % 1000000);
+	val->it_interval = start_timerval.it_interval;
+	return 0;
+}
+
+int setitimer(int which, const struct itimerval *val, struct itimerval *valout)
+{
+	FILETIME ft;
+	(void)which; (void)valout;
+	start_timerval = *val;
+	GetSystemTimeAsFileTime(&ft);
+	start_walltime = (((__int64)ft.dwHighDateTime << 32) | ft.dwLowDateTime);
+	return 0;
+}
diff -uNr hdparm-6.9.orig/win32/timer.h hdparm-6.9/win32/timer.h
--- hdparm-6.9.orig/win32/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/timer.h	2006-08-17 21:39:48.000000000 +0200
@@ -0,0 +1,20 @@
+/* win32/timer.h - sleep/itimer emulation module for hdparm for Windows */
+/*               - by Christian Franke (C) 2006 -- freely distributable */
+
+void sleep(int seconds);
+
+#define ITIMER_REAL 0
+
+struct timeval {
+	long tv_sec;
+	long tv_usec;
+};
+
+struct  itimerval {
+	struct timeval it_interval;
+	struct timeval it_value;
+};
+
+int getitimer(int which, struct itimerval * val);
+int setitimer(int which, const struct itimerval * val, struct itimerval * valout);
+
diff -uNr hdparm-6.9.orig/win32/version.h hdparm-6.9/win32/version.h
--- hdparm-6.9.orig/win32/version.h	1970-01-01 01:00:00.000000000 +0100
+++ hdparm-6.9/win32/version.h	2007-02-28 22:18:22.000000000 +0100
@@ -0,0 +1,12 @@
+/* hdparm for Windows version */
+#define VERSION_MAJOR "v6.9"
+#define VERSION_MINOR "20070228"
+
+#ifdef __CYGWIN__
+#define PLATFORM "Cygwin"
+#else
+#define PLATFORM "Win32"
+#endif
+
+#define VERSION  VERSION_MAJOR"-"VERSION_MINOR" ("PLATFORM")"
+

 	  	 
